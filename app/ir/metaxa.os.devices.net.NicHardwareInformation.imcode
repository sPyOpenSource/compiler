class metaxa/os/devices/net/NicHardwareInformation {
 
 method <init>()V {
  +START:   #1
        vR0.<init>@special();   [   R] 
        return;   
  +END:   #1
 }
// Register: rd 1/1 wr 0 swaps 0 any 0 found 0 <init>
 
 method set_CacheLineSize(B)V {
  +START:   #1
        vR0.CacheLineSize = vi1;   
        return;   
  +END:   #1
 }
// Register: rd 2/2 wr 0 swaps 0 any 0 found 0 set_CacheLineSize
 
 method set_RevisionId(B)V {
  +START:   #1
        vR0.RevisionId = vi1;   
        return;   
  +END:   #1
 }
// Register: rd 2/2 wr 0 swaps 0 any 0 found 0 set_RevisionId
 
 method set_Status(B)V {
  +START:   #1
        vR0.Status = vi1;   
        return;   
  +END:   #1
 }
// Register: rd 2/2 wr 0 swaps 0 any 0 found 0 set_Status
 
 method set_XcvrType(S)V {
  +START:   #1
        vR0.XcvrType = vi1;   
        return;   
  +END:   #1
 }
// Register: rd 2/2 wr 0 swaps 0 any 0 found 0 set_XcvrType
 
 method set_DeviceId(S)V {
  +START:   #1
        vR0.DeviceId = vi1;   
        return;   
  +END:   #1
 }
// Register: rd 2/2 wr 0 swaps 0 any 0 found 0 set_DeviceId
 
 method set_BitsInHashFilter(I)V {
  +START:   #1
        vR0.BitsInHashFilter = vi1;   
        return;   
  +END:   #1
 }
// Register: rd 2/2 wr 0 swaps 0 any 0 found 0 set_BitsInHashFilter
 
 method set_LinkSpeed(I)V {
  +START:   #1
        vR0.LinkSpeed = vi1;   
        return;   
  +END:   #1
 }
// Register: rd 2/2 wr 0 swaps 0 any 0 found 0 set_LinkSpeed
 
 method set_UpdateInterval(I)V {
  +START:   #1
        vR0.UpdateInterval = vi1;   
        return;   
  +END:   #1
 }
// Register: rd 2/2 wr 0 swaps 0 any 0 found 0 set_UpdateInterval
 
 method set_Connector(B)V {
  +START:   #1
        if vi1< 0 goto B10;   
  +B4:   #1
        if vi1<7 goto B35;   
  +B10:   #1
        if vi1==8 goto B35;   
  +B16:   #1
        if vi1==9 goto B35;   
  +B22:   #1
        if vi1==-1 goto B35;   
  -B27:   #1
        throw new metaxa/os/devices/net/UnknownConnectorType();   
  +B35:   #4
        vR0.Connector = vi1;   
        return;   
  +END:   #1
 }
// Register: rd 7/7 wr 0 swaps 0 any 5 found 0 set_Connector
 
 method set_ConfigConnector(B)V {
  +START:   #1
        if vi1< 0 goto B10;   
  +B4:   #1
        if vi1<7 goto B35;   
  +B10:   #1
        if vi1==8 goto B35;   
  +B16:   #1
        if vi1==9 goto B35;   
  +B22:   #1
        if vi1==-1 goto B35;   
  -B27:   #1
        throw new metaxa/os/devices/net/UnknownConnectorType();   
  +B35:   #4
        vR0.ConfigConnector = vi1;   
        return;   
  +END:   #1
 }
// Register: rd 7/7 wr 0 swaps 0 any 5 found 0 set_ConfigConnector
 
 method set_HurricaneEarlyRevision(Z)V {
  +START:   #1
        vR0.HurricaneEarlyRevision = vi1;   
        return;   
  +END:   #1
 }
// Register: rd 2/2 wr 0 swaps 0 any 0 found 0 set_HurricaneEarlyRevision
 
 method set_FeatureSet(B)V {
  +START:   #1
        vR0.FeatureSet = vi1;   
        return;   
  +END:   #1
 }
// Register: rd 2/2 wr 0 swaps 0 any 0 found 0 set_FeatureSet
 
 method set_OptimizeForThroughput(Z)V {
  +START:   #1
        vR0.OptimizeForThroughput = vi1;   
        return;   
  +END:   #1
 }
// Register: rd 2/2 wr 0 swaps 0 any 0 found 0 set_OptimizeForThroughput
 
 method set_OptimizeForCPU(Z)V {
  +START:   #1
        vR0.OptimizeForCPU = vi1;   
        return;   
  +END:   #1
 }
// Register: rd 2/2 wr 0 swaps 0 any 0 found 0 set_OptimizeForCPU
 
 method set_OptimizeNormal(Z)V {
  +START:   #1
        vR0.OptimizeNormal = vi1;   
        return;   
  +END:   #1
 }
// Register: rd 2/2 wr 0 swaps 0 any 0 found 0 set_OptimizeNormal
 
 method set_BroadcastErrDone(Z)V {
  +START:   #1
        vR0.BroadcastErrDone = vi1;   
        return;   
  +END:   #1
 }
// Register: rd 2/2 wr 0 swaps 0 any 0 found 0 set_BroadcastErrDone
 
 method set_UDPChecksumErrDone(Z)V {
  +START:   #1
        vR0.UDPChecksumErrDone = vi1;   
        return;   
  +END:   #1
 }
// Register: rd 2/2 wr 0 swaps 0 any 0 found 0 set_UDPChecksumErrDone
 
 method set_FullDuplexEnable(Z)V {
  +START:   #1
        vR0.FullDuplexEnable = vi1;   
        return;   
  +END:   #1
 }
// Register: rd 2/2 wr 0 swaps 0 any 0 found 0 set_FullDuplexEnable
 
 method set_DuplexCommandOverride(Z)V {
  +START:   #1
        vR0.DuplexCommandOverride = vi1;   
        return;   
  +END:   #1
 }
// Register: rd 2/2 wr 0 swaps 0 any 0 found 0 set_DuplexCommandOverride
 
 method set_MWIErrDone(Z)V {
  +START:   #1
        vR0.MWIErrDone = vi1;   
        return;   
  +END:   #1
 }
// Register: rd 2/2 wr 0 swaps 0 any 0 found 0 set_MWIErrDone
 
 method set_FlowControlEnable(Z)V {
  +START:   #1
        vR0.FlowControlEnable = vi1;   
        return;   
  +END:   #1
 }
// Register: rd 2/2 wr 0 swaps 0 any 0 found 0 set_FlowControlEnable
 
 method set_FlowControlSupported(Z)V {
  +START:   #1
        vR0.FlowControlSupported = vi1;   
        return;   
  +END:   #1
 }
// Register: rd 2/2 wr 0 swaps 0 any 0 found 0 set_FlowControlSupported
 
 method set_LinkBeatDisable(Z)V {
  +START:   #1
        vR0.LinkBeatDisable = vi1;   
        return;   
  +END:   #1
 }
// Register: rd 2/2 wr 0 swaps 0 any 0 found 0 set_LinkBeatDisable
 
 method set_SupportsPowerManagement(Z)V {
  +START:   #1
        vR0.SupportsPowerManagement = vi1;   
        return;   
  +END:   #1
 }
// Register: rd 2/2 wr 0 swaps 0 any 0 found 0 set_SupportsPowerManagement
 
 method set_WOLConnectorPresent(Z)V {
  +START:   #1
        vR0.WOLConnectorPresent = vi1;   
        return;   
  +END:   #1
 }
// Register: rd 2/2 wr 0 swaps 0 any 0 found 0 set_WOLConnectorPresent
 
 method set_AutoResetToD0(Z)V {
  +START:   #1
        vR0.AutoResetToD0 = vi1;   
        return;   
  +END:   #1
 }
// Register: rd 2/2 wr 0 swaps 0 any 0 found 0 set_AutoResetToD0
 
 method set_DontSleep(Z)V {
  +START:   #1
        vR0.DontSleep = vi1;   
        return;   
  +END:   #1
 }
// Register: rd 2/2 wr 0 swaps 0 any 0 found 0 set_DontSleep
 
 method set_D3Work(Z)V {
  +START:   #1
        vR0.D3Work = vi1;   
        return;   
  +END:   #1
 }
// Register: rd 2/2 wr 0 swaps 0 any 0 found 0 set_D3Work
 
 method set_WakeOnMagicPacket(Z)V {
  +START:   #1
        vR0.WakeOnMagicPacket = vi1;   
        return;   
  +END:   #1
 }
// Register: rd 2/2 wr 0 swaps 0 any 0 found 0 set_WakeOnMagicPacket
 
 method set_WakeOnLinkChange(Z)V {
  +START:   #1
        vR0.WakeOnLinkChange = vi1;   
        return;   
  +END:   #1
 }
// Register: rd 2/2 wr 0 swaps 0 any 0 found 0 set_WakeOnLinkChange
 
 method set_SQEDisable(Z)V {
  +START:   #1
        vR0.SQEDisable = vi1;   
        return;   
  +END:   #1
 }
// Register: rd 2/2 wr 0 swaps 0 any 0 found 0 set_SQEDisable
 
 method set_AutoSelect(Z)V {
  +START:   #1
        vR0.AutoSelect = vi1;   
        return;   
  +END:   #1
 }
// Register: rd 2/2 wr 0 swaps 0 any 0 found 0 set_AutoSelect
 
 method set_LightTen(Z)V {
  +START:   #1
        vR0.LightTen = vi1;   
        return;   
  +END:   #1
 }
// Register: rd 2/2 wr 0 swaps 0 any 0 found 0 set_LightTen
 
 method set_LinkState(B)V {
  +START:   #1
        if vi1==0 goto B22;   
  +B4:   #1
        if vi1==1 goto B22;   
  +B9:   #1
        if vi1==2 goto B22;   
  -B14:   #1
        throw new metaxa/os/devices/net/UnknownLinkState();   
  +B22:   #3
        vR0.LinkState = vi1;   
        return;   
  +END:   #1
 }
// Register: rd 5/5 wr 0 swaps 0 any 3 found 0 set_LinkState
 
 method set_MIIReadCommand(S)V {
  +START:   #1
        vR0.MIIReadCommand = vi1;   
        return;   
  +END:   #1
 }
// Register: rd 2/2 wr 0 swaps 0 any 0 found 0 set_MIIReadCommand
 
 method set_MIIWriteCommand(S)V {
  +START:   #1
        vR0.MIIWriteCommand = vi1;   
        return;   
  +END:   #1
 }
// Register: rd 2/2 wr 0 swaps 0 any 0 found 0 set_MIIWriteCommand
 
 method set_MIIPhyOui(S)V {
  +START:   #1
        vR0.MIIPhyOui = vi1;   
        return;   
  +END:   #1
 }
// Register: rd 2/2 wr 0 swaps 0 any 0 found 0 set_MIIPhyOui
 
 method set_MIIPhyModel(S)V {
  +START:   #1
        vR0.MIIPhyModel = vi1;   
        return;   
  +END:   #1
 }
// Register: rd 2/2 wr 0 swaps 0 any 0 found 0 set_MIIPhyModel
 
 method set_MIIPhyUsed(S)V {
  +START:   #1
        vR0.MIIPhyUsed = vi1;   
        return;   
  +END:   #1
 }
// Register: rd 2/2 wr 0 swaps 0 any 0 found 0 set_MIIPhyUsed
 
 method set_MediaOverride(S)V {
  +START:   #1
        vR0.MediaOverride = vi1;   
        return;   
  +END:   #1
 }
// Register: rd 2/2 wr 0 swaps 0 any 0 found 0 set_MediaOverride
 
 method set_phys(S)V {
  +START:   #1
        vR0.phys = vi1;   
        return;   
  +END:   #1
 }
// Register: rd 2/2 wr 0 swaps 0 any 0 found 0 set_phys
 
 method get_CacheLineSize()B {
  +START:   #1
        return vR0.CacheLineSize;   
  +END:   #1
 }
// Register: rd 1/1 wr 0 swaps 0 any 0 found 0 get_CacheLineSize
 
 method get_RevisionId()B {
  +START:   #1
        return vR0.RevisionId;   
  +END:   #1
 }
// Register: rd 1/1 wr 0 swaps 0 any 0 found 0 get_RevisionId
 
 method get_Status()B {
  +START:   #1
        return vR0.Status;   
  +END:   #1
 }
// Register: rd 1/1 wr 0 swaps 0 any 0 found 0 get_Status
 
 method get_XcvrType()S {
  +START:   #1
        return vR0.XcvrType;   
  +END:   #1
 }
// Register: rd 1/1 wr 0 swaps 0 any 0 found 0 get_XcvrType
 
 method get_DeviceId()S {
  +START:   #1
        return vR0.DeviceId;   
  +END:   #1
 }
// Register: rd 1/1 wr 0 swaps 0 any 0 found 0 get_DeviceId
 
 method get_BitsInHashFilter()I {
  +START:   #1
        return vR0.BitsInHashFilter;   
  +END:   #1
 }
// Register: rd 1/1 wr 0 swaps 0 any 0 found 0 get_BitsInHashFilter
 
 method get_LinkSpeed()I {
  +START:   #1
        return vR0.LinkSpeed;   
  +END:   #1
 }
// Register: rd 1/1 wr 0 swaps 0 any 0 found 0 get_LinkSpeed
 
 method get_UpdateInterval()I {
  +START:   #1
        return vR0.UpdateInterval;   
  +END:   #1
 }
// Register: rd 1/1 wr 0 swaps 0 any 0 found 0 get_UpdateInterval
 
 method get_Connector()B {
  +START:   #1
        return vR0.Connector;   
  +END:   #1
 }
// Register: rd 1/1 wr 0 swaps 0 any 0 found 0 get_Connector
 
 method get_ConfigConnector()B {
  +START:   #1
        return vR0.ConfigConnector;   
  +END:   #1
 }
// Register: rd 1/1 wr 0 swaps 0 any 0 found 0 get_ConfigConnector
 
 method get_HurricaneEarlyRevision()Z {
  +START:   #1
        return vR0.HurricaneEarlyRevision;   
  +END:   #1
 }
// Register: rd 1/1 wr 0 swaps 0 any 0 found 0 get_HurricaneEarlyRevision
 
 method get_FeatureSet()B {
  +START:   #1
        return vR0.FeatureSet;   
  +END:   #1
 }
// Register: rd 1/1 wr 0 swaps 0 any 0 found 0 get_FeatureSet
 
 method get_OptimizeForThroughput()Z {
  +START:   #1
        return vR0.OptimizeForThroughput;   
  +END:   #1
 }
// Register: rd 1/1 wr 0 swaps 0 any 0 found 0 get_OptimizeForThroughput
 
 method get_OptimizeForCPU()Z {
  +START:   #1
        return vR0.OptimizeForCPU;   
  +END:   #1
 }
// Register: rd 1/1 wr 0 swaps 0 any 0 found 0 get_OptimizeForCPU
 
 method get_OptimizeNormal()Z {
  +START:   #1
        return vR0.OptimizeNormal;   
  +END:   #1
 }
// Register: rd 1/1 wr 0 swaps 0 any 0 found 0 get_OptimizeNormal
 
 method get_BroadcastErrDone()Z {
  +START:   #1
        return vR0.BroadcastErrDone;   
  +END:   #1
 }
// Register: rd 1/1 wr 0 swaps 0 any 0 found 0 get_BroadcastErrDone
 
 method get_UDPChecksumErrDone()Z {
  +START:   #1
        return vR0.UDPChecksumErrDone;   
  +END:   #1
 }
// Register: rd 1/1 wr 0 swaps 0 any 0 found 0 get_UDPChecksumErrDone
 
 method get_FullDuplexEnable()Z {
  +START:   #1
        return vR0.FullDuplexEnable;   
  +END:   #1
 }
// Register: rd 1/1 wr 0 swaps 0 any 0 found 0 get_FullDuplexEnable
 
 method get_DuplexCommandOverride()Z {
  +START:   #1
        return vR0.DuplexCommandOverride;   
  +END:   #1
 }
// Register: rd 1/1 wr 0 swaps 0 any 0 found 0 get_DuplexCommandOverride
 
 method get_MWIErrDone()Z {
  +START:   #1
        return vR0.MWIErrDone;   
  +END:   #1
 }
// Register: rd 1/1 wr 0 swaps 0 any 0 found 0 get_MWIErrDone
 
 method get_FlowControlEnable()Z {
  +START:   #1
        return vR0.FlowControlEnable;   
  +END:   #1
 }
// Register: rd 1/1 wr 0 swaps 0 any 0 found 0 get_FlowControlEnable
 
 method get_FlowControlSupported()Z {
  +START:   #1
        return vR0.FlowControlSupported;   
  +END:   #1
 }
// Register: rd 1/1 wr 0 swaps 0 any 0 found 0 get_FlowControlSupported
 
 method get_LinkBeatDisable()Z {
  +START:   #1
        return vR0.LinkBeatDisable;   
  +END:   #1
 }
// Register: rd 1/1 wr 0 swaps 0 any 0 found 0 get_LinkBeatDisable
 
 method get_SupportsPowerManagement()Z {
  +START:   #1
        return vR0.SupportsPowerManagement;   
  +END:   #1
 }
// Register: rd 1/1 wr 0 swaps 0 any 0 found 0 get_SupportsPowerManagement
 
 method get_WOLConnectorPresent()Z {
  +START:   #1
        return vR0.WOLConnectorPresent;   
  +END:   #1
 }
// Register: rd 1/1 wr 0 swaps 0 any 0 found 0 get_WOLConnectorPresent
 
 method get_AutoResetToD0()Z {
  +START:   #1
        return vR0.AutoResetToD0;   
  +END:   #1
 }
// Register: rd 1/1 wr 0 swaps 0 any 0 found 0 get_AutoResetToD0
 
 method get_DontSleep()Z {
  +START:   #1
        return vR0.DontSleep;   
  +END:   #1
 }
// Register: rd 1/1 wr 0 swaps 0 any 0 found 0 get_DontSleep
 
 method get_D3Work()Z {
  +START:   #1
        return vR0.D3Work;   
  +END:   #1
 }
// Register: rd 1/1 wr 0 swaps 0 any 0 found 0 get_D3Work
 
 method get_WakeOnMagicPacket()Z {
  +START:   #1
        return vR0.WakeOnMagicPacket;   
  +END:   #1
 }
// Register: rd 1/1 wr 0 swaps 0 any 0 found 0 get_WakeOnMagicPacket
 
 method get_WakeOnLinkChange()Z {
  +START:   #1
        return vR0.WakeOnLinkChange;   
  +END:   #1
 }
// Register: rd 1/1 wr 0 swaps 0 any 0 found 0 get_WakeOnLinkChange
 
 method get_SQEDisable()Z {
  +START:   #1
        return vR0.SQEDisable;   
  +END:   #1
 }
// Register: rd 1/1 wr 0 swaps 0 any 0 found 0 get_SQEDisable
 
 method get_AutoSelect()Z {
  +START:   #1
        return vR0.AutoSelect;   
  +END:   #1
 }
// Register: rd 1/1 wr 0 swaps 0 any 0 found 0 get_AutoSelect
 
 method get_LightTen()Z {
  +START:   #1
        return vR0.LightTen;   
  +END:   #1
 }
// Register: rd 1/1 wr 0 swaps 0 any 0 found 0 get_LightTen
 
 method get_LinkState()B {
  +START:   #1
        return vR0.LinkState;   
  +END:   #1
 }
// Register: rd 1/1 wr 0 swaps 0 any 0 found 0 get_LinkState
 
 method get_MIIReadCommand()S {
  +START:   #1
        return vR0.MIIReadCommand;   
  +END:   #1
 }
// Register: rd 1/1 wr 0 swaps 0 any 0 found 0 get_MIIReadCommand
 
 method get_MIIWriteCommand()S {
  +START:   #1
        return vR0.MIIWriteCommand;   
  +END:   #1
 }
// Register: rd 1/1 wr 0 swaps 0 any 0 found 0 get_MIIWriteCommand
 
 method get_MIIPhyOui()S {
  +START:   #1
        return vR0.MIIPhyOui;   
  +END:   #1
 }
// Register: rd 1/1 wr 0 swaps 0 any 0 found 0 get_MIIPhyOui
 
 method get_MIIPhyModel()S {
  +START:   #1
        return vR0.MIIPhyModel;   
  +END:   #1
 }
// Register: rd 1/1 wr 0 swaps 0 any 0 found 0 get_MIIPhyModel
 
 method get_MIIPhyUsed()S {
  +START:   #1
        return vR0.MIIPhyUsed;   
  +END:   #1
 }
// Register: rd 1/1 wr 0 swaps 0 any 0 found 0 get_MIIPhyUsed
 
 method get_MediaOverride()S {
  +START:   #1
        return vR0.MediaOverride;   
  +END:   #1
 }
// Register: rd 1/1 wr 0 swaps 0 any 0 found 0 get_MediaOverride
 
 method get_phys()S {
  +START:   #1
        return vR0.phys;   
  +END:   #1
 }
// Register: rd 1/1 wr 0 swaps 0 any 0 found 0 get_phys
}
