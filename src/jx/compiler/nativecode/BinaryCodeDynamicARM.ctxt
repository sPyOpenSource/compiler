#BlueJ class context
comment0.target=BinaryCodeDynamicARM
comment0.text=\ \n\ \ \ \ Parallel\ to\ this\ class\ there\ is\ a\ class\ \n\ \ \ \ nativeCode.Binarycode.\ \n\ \ \ \ In\ this\ version\ of\ the\ compiler,\ the\ second\ class\ \n\ \ \ \ is\ used\ as\ a\ mere\ container,\ while\ this\ class\ \n\ \ \ \ is\ used\ to\ assemble\ the\ binary\ code.\ \n
comment1.params=
comment1.target=BinaryCodeDynamicARM()
comment10.params=entry
comment10.target=void\ call(jx.compiler.symbols.SymbolTableEntryBase)
comment10.text=\n\ \ \ \ \ \ \ Insert\ call\ near\ (Symbol)\ (1\ clks)\n\ @param\ entry\n
comment100.params=des
comment100.target=void\ jmp(Opr)
comment101.params=entry
comment101.target=void\ jmp(jx.compiler.symbols.SymbolTableEntryBase)
comment102.params=index\ tables
comment102.target=void\ jmp(Reg,\ jx.compiler.symbols.SymbolTableEntryBase[])
comment103.params=src\ des
comment103.target=void\ movb(Opr,\ Reg)
comment103.text=\n\ \ \ \ \ \ \ Move\ 8\ Bit\ Data\n
comment104.params=src\ des
comment104.target=void\ movb(Reg,\ Ref)
comment105.params=immd\ des
comment105.target=void\ movb(int,\ Opr)
comment106.params=src\ des
comment106.target=void\ movw(Opr,\ Reg)
comment106.text=\ \n\tMove\ 16\ Bit\ Data\n
comment107.params=src\ des
comment107.target=void\ movw(Reg,\ Ref)
comment108.params=src\ des
comment108.target=void\ movl(Opr,\ Reg)
comment108.text=\n\ \ \ \ \ \ \ Move\ 32\ Bit\ Data\n
comment109.params=src\ des
comment109.target=void\ movl(Reg,\ Ref)
comment11.params=
comment11.target=void\ cbw()
comment11.text=\n\ \ \ \ \ \ \ Convert\ byte\ to\ word\ (3\ clks)\ +\ (..\ clks)\n
comment110.params=immd\ des
comment110.target=void\ movl(int,\ Opr)
comment111.params=entry\ des
comment111.target=void\ movl(jx.compiler.symbols.SymbolTableEntryBase,\ Opr)
comment112.params=src\ des
comment112.target=void\ movzwl(Opr,\ Reg)
comment112.text=\n\ \ \ \ \ \ \ Move\ with\ Zero-Extend\ (short)\ (3\ clks)\n
comment113.params=src\ des
comment113.target=void\ movzbl(Opr,\ Reg)
comment113.text=\n\ \ \ \ \ \ \ move\ with\ Zero-Extend\ (byte)\ (3\ clks)\n
comment114.params=src\ des
comment114.target=void\ movswl(Opr,\ Reg)
comment114.text=\n\ \ \ \ \ \ \ Move\ with\ Sign-Extend\ (short\ to\ register)\ (3\ clks)\n
comment115.params=src\ des
comment115.target=void\ movsbl(Opr,\ Reg)
comment115.text=\n\ \ \ \ \ \ \ Move\ with\ Sign-Extend\ (byte\ to\ register)\ (3\ clks)\n
comment116.params=
comment116.target=void\ nop()
comment116.text=\n\ \ \ \ \ \ \ No\ Operation\ (1\ clks)\n
comment117.params=
comment117.target=void\ wrmsr()
comment117.text=\n\ \ \ \ \ \ \ write\ to\ model\ specific\ register\ (30-45\ clks)\n\n\ \ \ \ \ \ \ ecx\ \ |\ register\n\ \ \ \ \ \ \ \=\=\=\=\=\=\=\=\=\=\=\=\=\=\=\=\=\=\=\=\=\=\=\=\=\=\=\=\=\n\ \ \ \ \ \ \ 0x00\ |\ machine\ check\ address\n\ \ \ \ \ \ \ 0x01\ |\ machine\ check\ type\n\ \ \ \ \ \ \ \=\=\=\=\=\=\=\=\=\=\=\=\=\=\=\=\=\=\=\=\=\=\=\=\=\=\=\=\=\n\ \ \ \ \ \ \ 0x10\ |\ time\ stamp\ counter\n\ \ \ \ \ \ \ 0x11\ |\ control\ and\ event\ select\n\ \ \ \ \ \ \ 0x12\ |\ counter\ 0\n\ \ \ \ \ \ \ 0x13\ |\ counter\ 1\n\n
comment118.params=
comment118.target=void\ rdmsr()
comment118.text=\n\ \ \ \ \ \ \ read\ from\ model\ specific\ register\ (20-24\ clks)\n\n\ \ \ \ \ \ \ see\ wrmsr()\ for\ register\ selection\n
comment119.params=
comment119.target=void\ rdtsc()
comment119.text=\n\ \ \ \ \ \ \ Read\ from\ Time\ Stamp\ Counter\ \n\ \ \ \ \ \ \ return\ EDX\:EAX\n
comment12.params=
comment12.target=void\ cdq()
comment12.text=\n\ \ \ \ \ \ \ Convert\ double\ to\ quad\ word\ (2\ clks)\n\n\ \ \ \ \ \ \ fill\ edx\ with\ sign\ bit\ of\ eax\n
comment120.params=
comment120.target=void\ rdpmc()
comment120.text=\ \n\ \ \ \ \ \ \ read\ performance\ monitor\ counter\n\ \ \ \ \ \ \ (only\ P6)\n\ \ \ \ \ \ \ \n\ \ \ \ \ \ \ ecx\ \=\ 0\ \:\ return\ EDX\:EAX\ counter0\n\ \ \ \ \ \ \ ecx\ \=\ 1\ \:\ return\ EDX\:EAX\ counter1\n
comment121.params=src\ des
comment121.target=void\ test(Opr,\ Reg)
comment121.text=\n\ \ \ \ \ \ \ test\ -\ logical\ compare\ (1/2\ clks)\n
comment122.params=immd\ des
comment122.target=void\ test(int,\ Opr)
comment123.params=value
comment123.target=void\ insertConst1(int)
comment123.text=\ \n\tInsert\ a\ single\ byte\ constant\ \n
comment124.params=value
comment124.target=void\ insertConst4(int)
comment124.text=\ \n\tInsert\ a\ four\ byte\ constant\ \n
comment125.params=ncIndex\ value
comment125.target=void\ insertConst4At(int,\ int)
comment126.params=entry
comment126.target=void\ insertConst4(jx.compiler.symbols.SymbolTableEntryBase)
comment126.text=\ \n\tInsert\ a\ four\ byte\ constant\ with\ an\ unknown\ value.\ \n\t(must\ be\ resolved\ before\ the\ code\ is\ installed)\ \n
comment127.params=value
comment127.target=boolean\ is8BitValue(int)
comment128.params=entry
comment128.target=void\ insertConst0(jx.compiler.symbols.SymbolTableEntryBase)
comment128.text=\ \n\tInsert\ a\ 0\ byte\ constant\ with\ an\ unknown\ value.\ \n\t(contains\ information\ about\ current\ code\ position,\ i.e.,\ a\ stack\ map)\ \n
comment129.params=
comment129.target=void\ alignCode()
comment129.text=\n\ \ \ \ \ \ \ Intel\ Architecture\ Optimization.\ Reference\ Manual\ (chapter\ 2,page\ 11)\n\ \ \ \ \ \ \ "Pentium\ II\ and\ III\ processors\ have\ a\ cache\ line\ size\ of\ 32\ byte.\n\ \ \ \ \ \ \ Since\ the\ instruction\ prefetch\ buffers\ fetch\ 16-byte\ boundaries,\n\ \ \ \ \ \ \ code\ alignment\ has\ a\ direct\ impact\ on\ prefetch\ buffer\ efficiency"\n\ \ \ \ \ \ \ \n\ Loop\ entry\ labels\ should\ be\ 16-byte-aligned\ when\ less\ then\ \n\ \ \ \ \ \ \ eight\ byte\ away\ from\ a\ 16-byte\ boundary.\n\ \ \ \ \ \ \ \n\ Labels\ that\ follow\ an\ unconditional\ branch\ of\ function\ call\n\ \ \ \ \ \ \ should\ be\ aligend\ as\ above.\n\ \ \ \ \ \ \ \n\ Labels\ that\ follow\ a\ conditional\ branch\ need\ _not_\ be\ aligned.\n
comment13.params=
comment13.target=void\ cwde()
comment13.text=\n\ \ \ \ \ \ \ Convert\ word\ to\ double\ word\ (3\ clks)\n\ \ \ \ \ \ \ fill\ dx\ with\ sign\ bit\ of\ ax\n
comment130.params=jumpObject
comment130.target=void\ addJumpTarget(jx.compiler.symbols.UnresolvedJump)
comment130.text=\ \n\tInitialized\ the\ target\ position\ of\ 'jumpObject'.\ \n\t(Call\ insertConst4()\ for\ corresponding\ jump\ instruction)\ \n
comment131.params=
comment131.target=void\ alignIP()
comment132.params=
comment132.target=void\ alignIP_4_Byte()
comment133.params=
comment133.target=void\ alignIP_16_Byte()
comment134.params=
comment134.target=void\ alignIP_32_Byte()
comment135.params=handler
comment135.target=void\ addExceptionTarget(jx.compiler.symbols.UnresolvedJump)
comment136.params=entry
comment136.target=void\ makeRelative(jx.compiler.symbols.SymbolTableEntryBase)
comment136.text=\ \n\tMake\ a\ symbol\ table\ entry\ relative.\ \n\tIf\ you\ use\ insertConst4(),\ this\ class\ assumes\ that\ \n\tthe\ value\ to\ be\ inserted\ is\ absolute.\ But\ if\ the\ \n\tinserted\ value\ is\ a\ jump\ offset\ it\ is\ relative\ to\ \n\tthe\ instruction\ pointer\ of\ the\ next\ instruction.\ \n\tThat\ is\ what\ you\ can\ tell\ the\ compiler\ with\ this\ \n\tmethod.\ \n
comment137.params=
comment137.target=void\ endInstr()
comment137.text=\n\ \ \ \ \ \ \ Called\ after\ each\ instruction.\ \n
comment138.params=
comment138.target=void\ finishCode()
comment139.params=codeBase
comment139.target=void\ resolve(int)
comment139.text=\ \n\tApply\ all\ resolveable\ symbol\ table\ entries.\n\t(e.g.\ insert\ jump\ offsets\ ....)\n\tAfter\ calling\ this\ method,\ the\ vector\ 'symbolTable'\ \n\tcontains\ all\ symbol\ table\ entries\ that\ are\ not\ resolveable.\n\tIf\ you\ want\ to\ install\ the\ compiled\ code\ after\ calling\ this\ \n\tmethod,\ this\ vector\ should\ be\ empty.\ \n\ @param\ codeBase\n
comment14.params=
comment14.target=void\ cwd()
comment14.text=\n\ \ \ \ \ \ \ Convert\ word\ to\ double\ (2\ clks)\n\ \ \ \ \ \ \ fill\ dx\ with\ sign\ bit\ of\ ax\n
comment140.params=reg
comment140.target=java.lang.String\ regToString(int)
comment141.params=handler
comment141.target=void\ addExceptionRangeStart(NCExceptionHandler)
comment142.params=handler
comment142.target=void\ addExceptionRangeEnd(NCExceptionHandler)
comment143.params=handler
comment143.target=void\ addExceptionHandler(NCExceptionHandler)
comment143.text=\n\tadd\ a\ start\ of\ an\ exception\ handler.\n\ @param\ handler\n
comment144.params=
comment144.target=NCExceptionHandler[]\ getExceptionHandlers()
comment144.text=\n\treturn\ an\ array\ of\ all\ exception\ handlers\ of\ this\ \n\tmethod.\ (these\ handlers\ contain\ the\ native\ code\ indices\ \n\tof\ the\ range\ start,\ range\ end\ and\ of\ the\ handler\ start\ \n\ @return\n
comment145.params=firstByte\ stopByte
comment145.target=java.lang.String\ getBinaryCodeAsHex(int,\ int)
comment146.params=
comment146.target=java.lang.String\ getBinaryCodeAsHex()
comment147.params=firstByte\ stopByte
comment147.target=java.lang.String\ getBinaryCodeAsAssembler(int,\ int)
comment148.params=
comment148.target=java.lang.String\ getBinaryCodeAsAssembler()
comment149.params=instr\ arg1\ arg2
comment149.target=void\ printInstr(java.lang.String,\ java.lang.String,\ jx.compiler.symbols.SymbolTableEntryBase)
comment15.params=
comment15.target=void\ ret()
comment15.text=\n\ \ \ \ \ \ \ Insert\ return\n
comment150.params=instr\ arg1\ arg2
comment150.target=void\ printInstr(java.lang.String,\ jx.compiler.symbols.SymbolTableEntryBase,\ java.lang.String)
comment151.params=instr\ arg1\ arg2\ arg3
comment151.target=void\ printInstr(java.lang.String,\ java.lang.String,\ jx.compiler.symbols.SymbolTableEntryBase,\ java.lang.String)
comment152.params=instr
comment152.target=void\ printInstr(java.lang.String)
comment153.params=instr\ arg1\ arg2
comment153.target=void\ printInstr(java.lang.String,\ java.lang.String,\ java.lang.String)
comment154.params=instr\ arg1
comment154.target=void\ printInstr(java.lang.String,\ jx.compiler.symbols.SymbolTableEntryBase)
comment155.params=entry
comment155.target=void\ printJumpTarget(jx.compiler.symbols.UnresolvedJump)
comment156.params=value
comment156.target=void\ printHexByte(int)
comment157.params=value
comment157.target=void\ printHexInt(int)
comment158.params=
comment158.target=void\ printInstructions()
comment159.params=out
comment159.target=void\ printGASInstructions(java.io.PrintStream)
comment16.params=
comment16.target=void\ cli()
comment16.text=\n\ \ \ \ \ \ \ clear\ interrupt\ flag\ (7\ clks)\n
comment160.params=bcPosition
comment160.target=void\ startBC(int)
comment161.params=
comment161.target=void\ endBC()
comment162.params=
comment162.target=java.util.ArrayList\ getInstructionTable()
comment17.params=opr
comment17.target=void\ decb(Opr)
comment17.text=\n\ \ \ \ \ \ \ decrement\ byte\ value\ by\ 1\ (1/3\ clks)\n\ @param\ opr\n
comment18.params=ref
comment18.target=void\ decl(Ref)
comment18.text=\n\ \ \ \ \ \ \ decrement\ long\ value\ by\ 1\ (1/3\ clks)\n\ @param\ ref\n
comment19.params=reg
comment19.target=void\ decl(Reg)
comment19.text=\ \n\ \ \ \ \ \ \ decrement\ register\ by\ 1\ (1\ clks)\n\ @param\ reg\n
comment2.params=
comment2.target=int\ getCurrentIP()
comment2.text=\n\ \ \ \ public\ jx.jit.nativecode.BinaryCode\ getOldBinaryCode()\ {\n\n\tEnumeration\ enum\ \=\ symbolTable.elements();\ \n\tVector\ unresolvedEntries\ \=\ new\ Vector();\ \n\twhile(enum.hasMoreElements())\ {\n\t\ \ \ \ SymbolTableEntryBase\ entry\ \=\ (SymbolTableEntryBase)enum.nextElement();\n\t\ \ \ \ if\ (entry\ instanceof\ IntValueSTEntry)\ {\n\t\t((IntValueSTEntry)entry).applyValue(code);\n\t\t//entry.apply(code,\ codeBase);\n\t\ \ \ \ }\ else\ {\n\t\tunresolvedEntries.addElement(entry);\ \n\t\ \ \ \ }\n\t}\n\tsymbolTable\ \=\ unresolvedEntries;\ \n\n\ \ \ \ \ \ return\ new\ jx.jit.nativecode.BinaryCode(code,\ ip,\ symbolTable);\ \n\ \ \ \ }\n
comment20.params=reg
comment20.target=void\ pushl(Reg)
comment20.text=\n\ \ \ \ \ \ \ Insert\ a\ pushl(reg)\n\ @param\ reg\n
comment21.params=ref
comment21.target=void\ pushl(Ref)
comment22.params=immd
comment22.target=void\ pushl(int)
comment23.params=entry
comment23.target=void\ pushl(jx.compiler.symbols.SymbolTableEntryBase)
comment24.params=
comment24.target=void\ pushfl()
comment25.params=
comment25.target=void\ pushal()
comment25.text=\n\ \ \ \ \ \ \ push\ all\ general\ registers\n\ \ \ \ \ \ \ (eax,ecx,edx,ebx,esp,ebp,esi,edi)\ \n\ \ \ \ \ \ \ (5\ clks)\n
comment26.params=reg
comment26.target=void\ popl(Reg)
comment26.text=\ \n\ \ \ \ \ \ \ Insert\ a\ popl(reg)\n\ @param\ reg\n
comment27.params=
comment27.target=void\ popfl()
comment27.text=\n\ \ \ \ \ \ \ pop\ stack\ into\ eflags\ register\ (4\ clks)\n
comment28.params=
comment28.target=void\ popal()
comment28.text=\n\ \ \ \ \ \ \ pop\ all\ general\ register\n
comment29.params=
comment29.target=void\ lock()
comment29.text=\ \n\ \ \ \ \ \ lock\ prefix\n
comment3.params=
comment3.target=void\ realloc()
comment30.params=
comment30.target=void\ repz()
comment30.text=\n\ \ \ \ \ rep\ prefix\n
comment31.params=lock
comment31.target=void\ spin_lock(Ref)
comment31.text=\ \n\ \ \ \ \ \ \ spinlocks\n\ @param\ lock\n
comment32.params=lock
comment32.target=void\ spin_unlock(Ref)
comment33.params=src\ des
comment33.target=void\ subl(Opr,\ Reg)
comment33.text=\n\ \ \ \ \ \ \ Integer\ Subtraction\n\ @param\ src\n\ @param\ des\n
comment34.params=src\ des
comment34.target=void\ subl(Reg,\ Ref)
comment35.params=immd\ des
comment35.target=void\ subl(int,\ Opr)
comment36.params=entry\ des
comment36.target=void\ subl(jx.compiler.symbols.SymbolTableEntryBase,\ Opr)
comment37.params=src\ des
comment37.target=void\ sbbl(Opr,\ Reg)
comment37.text=\n\ \ \ \ \ \ \ Integer\ Subtraction\ with\ Borrow\n\ @param\ src\n\ @param\ des\n
comment38.params=src\ des
comment38.target=void\ sbbl(Reg,\ Ref)
comment39.params=src
comment39.target=void\ mull(Opr)
comment39.text=\n\ \ \ \ \ \ \ Integer\ Unsigned\ Multiplication\ of\ eax\ \ (10\ clk)\n\ @param\ src\n
comment4.params=requiredSpace
comment4.target=void\ realloc(int)
comment4.text=\ \n\tRealloc\ memory\ in\ the\ byte\ code\ array.\ \n\tAfter\ calling\ this\ method,\ there\ are\ at\ least\ \n\t'requiredSpace'\ free\ bytes\ in\ the\ array.\ \n\ @param\ requiredSpace\n
comment40.params=src\ des
comment40.target=void\ imull(Opr,\ Reg)
comment40.text=\n\ \ \ \ \ \ \ Integer\ Signed\ Multiplication\ (10\ clk)\n\ @param\ src\n\ @param\ des\n
comment41.params=immd\ des
comment41.target=void\ imull(int,\ Reg)
comment41.text=imull(Reg\ src,\ Ref\ des)\ no\ x86-code
comment42.params=immd\ src\ des
comment42.target=void\ imull(int,\ Opr,\ Reg)
comment43.params=entry\ des
comment43.target=void\ imull(jx.compiler.symbols.SymbolTableEntryBase,\ Reg)
comment44.params=opr
comment44.target=void\ incb(Opr)
comment44.text=\n\ \ \ \ \ \ \ increment\ by\ 1\ (1/3\ clks)\n\ @param\ opr\n
comment45.params=ref
comment45.target=void\ incl(Ref)
comment45.text=\ \n\ \ \ \ \ \ \ increment\ by\ 1\ (1/3\ clks)\n\ @param\ ref\n
comment46.params=reg
comment46.target=void\ incl(Reg)
comment46.text=\n\ \ \ \ \ \ \ increment\ register\ by\ 1\ (1\ clks)\n\ @param\ reg\n
comment47.params=opr\ reg
comment47.target=void\ lea(Opr,\ Reg)
comment47.text=\ \n\tlea\ Load\ Effective\ Address\ (1\ clk)\n\ \ \n\ \ \ \ \ \ \ \ m\ \=\ index\ *\ [0,1,2,4,8]\ +\ base\ +\ disp\n\n\ \ \ \ \ \ \ \ base.disp(disp,index,[0,1,2,4,8])\n\ @param\ opr\ \ \ \ \ \ \ \ \n\ @param\ reg\ \ \ \ \ \ \ \ \n
comment48.params=immd\ des
comment48.target=void\ shll(int,\ Opr)
comment48.text=\n\ \ \ \ \ \ \ SHL/SAL\ Shift\ left\ (1/3\ clks)\n\ @param\ immd\n\ @param\ des\n
comment49.params=des
comment49.target=void\ shll(Opr)
comment49.text=\n\ \ \ \ \ \ \ SHL/SAL\ Shift\ left\ by\ %cl\ (4\ clks)\n\ @param\ des\n
comment5.params=value
comment5.target=void\ insertByte(int)
comment5.text=\ \n\tInsert\ a\ single\ byte\n
comment50.params=immd\ low\ des
comment50.target=void\ shld(int,\ Reg,\ Opr)
comment50.text=\n\ \ \ \ \ \ \ SHLD\ Double\ Precision\ Shift\ left\ (4\ clks)\n\ @param\ immd\n\ @param\ low\n\ @param\ des\n
comment51.params=low\ des
comment51.target=void\ shld(Reg,\ Opr)
comment51.text=\n\ \ \ \ \ \ \ SHLD\ Double\ Precision\ Shift\ left\ by\ %cl\ (4/5\ clks)\n\ @param\ low\n\ @param\ des\n
comment52.params=immd\ des
comment52.target=void\ shrl(int,\ Opr)
comment52.text=\n\ \ \ \ \ \ \ SHR\ Shift\ right\ (1/3\ clks)\n\ @param\ immd\n\ @param\ des\n
comment53.params=entry\ des
comment53.target=void\ shrl(jx.compiler.symbols.SymbolTableEntryBase,\ Opr)
comment54.params=des
comment54.target=void\ shrl(Opr)
comment54.text=\n\ \ \ \ \ \ \ SHL/SAL\ Shift\ left\ by\ %cl\ (4\ clks)\n\ @param\ des\n
comment55.params=immd\ des
comment55.target=void\ sarl(int,\ Opr)
comment55.text=\n\ \ \ \ \ \ \ SAR\ Shift\ right\ (signed)\ (1/3\ clks)\n\ @param\ immd\n\ @param\ des\n
comment56.params=des
comment56.target=void\ sarl(Opr)
comment56.text=\n\ \ \ \ \ \ \ SAR\ Shift\ right\ by\ %cl\ (signed)\ (4\ clks)\n\ @param\ des\n
comment57.params=src
comment57.target=void\ idivl(Opr)
comment57.text=\n\ \ \ \ \ \ \ DIV\ Signed\ Divide\n\ @param\ src\n
comment58.params=src
comment58.target=void\ divl(Opr)
comment58.text=\n\ \ \ \ \ \ \ DIV\ Unsigned\ Divide\n\ @param\ src\n
comment59.params=src\ des
comment59.target=void\ addl(Opr,\ Reg)
comment59.text=\n\ \ \ \ \ \ \ Add\n\ @param\ src\n\ @param\ des\n
comment6.params=entry
comment6.target=void\ insertByte(jx.compiler.symbols.SymbolTableEntryBase)
comment60.params=src\ des
comment60.target=void\ addl(Reg,\ Ref)
comment61.params=immd\ des
comment61.target=void\ addl(int,\ Opr)
comment62.params=entry\ des
comment62.target=void\ addl(jx.compiler.symbols.SymbolTableEntryBase,\ Opr)
comment63.params=src\ des
comment63.target=void\ andl(Opr,\ Reg)
comment63.text=\n\ \ \ \ \ \ \ And\ (1/3\ clks)\n
comment64.params=src\ des
comment64.target=void\ andl(Reg,\ Ref)
comment65.params=immd\ des
comment65.target=void\ andl(int,\ Opr)
comment66.params=entry\ des
comment66.target=void\ andl(jx.compiler.symbols.SymbolTableEntryBase,\ Opr)
comment67.params=src\ des
comment67.target=void\ orl(Opr,\ Reg)
comment67.text=\n\ \ \ \ \ \ \ Or\ (1/3\ clks)\n
comment68.params=src\ des
comment68.target=void\ orl(Reg,\ Ref)
comment69.params=immd\ des
comment69.target=void\ orl(int,\ Opr)
comment7.params=reg\ rm
comment7.target=void\ insertModRM(int,\ Opr)
comment7.text=\n\ \ \ \ \ \ \ Insert\ ModRM\ and\ SIB\ byte\ \n
comment70.params=entry\ des
comment70.target=void\ orl(jx.compiler.symbols.SymbolTableEntryBase,\ Opr)
comment71.params=src\ des
comment71.target=void\ xorl(Opr,\ Reg)
comment71.text=\n\ \ \ \ \ \ \ Or\ (1/3\ clks)\n
comment72.params=src\ des
comment72.target=void\ xorl(Reg,\ Ref)
comment73.params=immd\ des
comment73.target=void\ xorl(int,\ Opr)
comment74.params=entry\ des
comment74.target=void\ xorl(jx.compiler.symbols.SymbolTableEntryBase,\ Opr)
comment75.params=opr
comment75.target=void\ notl(Opr)
comment75.text=\n\ \ \ \ \ \ \ Not\ (1/3\ clks)\n
comment76.params=opr
comment76.target=void\ negl(Opr)
comment76.text=\n\ \ \ \ \ \ \ Neg\ (1/3\ clks)\n
comment77.params=src\ des
comment77.target=void\ adcl(Opr,\ Reg)
comment77.text=\n\ \ \ \ \ \ \ Add\ with\ Carry\n
comment78.params=src\ des
comment78.target=void\ adcl(Reg,\ Ref)
comment79.params=immd\ des
comment79.target=void\ cmpb(int,\ Opr)
comment79.text=\n\ \ \ \ \ \ \ Compare\ Two\ Operands\n
comment8.params=reg\ rm
comment8.target=void\ insertModRM(Reg,\ Opr)
comment80.params=src\ des
comment80.target=void\ cmpl(Opr,\ Reg)
comment81.params=src\ des
comment81.target=void\ cmpl(Reg,\ Ref)
comment82.params=immd\ des
comment82.target=void\ cmpl(int,\ Opr)
comment83.params=entry\ des
comment83.target=void\ cmpl(jx.compiler.symbols.SymbolTableEntryBase,\ Opr)
comment84.params=des
comment84.target=void\ sete(Opr)
comment84.text=\n\ @param\ des\n
comment85.params=des
comment85.target=void\ setne(Opr)
comment86.params=nr
comment86.target=void\ intr(int)
comment87.params=rel
comment87.target=void\ je(int)
comment87.text=\n\ \ \ \ \ \ \ Jump\ short/near\ if\ equal\n
comment88.params=entry
comment88.target=void\ je(jx.compiler.symbols.SymbolTableEntryBase)
comment89.params=rel
comment89.target=void\ jne(int)
comment89.text=\n\ \ \ \ \ \ \ Jump\ short/near\ if\ not\ equal\n
comment9.params=opr
comment9.target=void\ call(Opr)
comment9.text=\n\ \ \ \ \ \ \ Insert\ call\ near\ indirect\ (reg/mem)\ (2\ clks)\n\ @param\ opr\n
comment90.params=entry
comment90.target=void\ jne(jx.compiler.symbols.SymbolTableEntryBase)
comment91.params=entry
comment91.target=void\ jnae(jx.compiler.symbols.SymbolTableEntryBase)
comment92.params=entry
comment92.target=void\ jl(jx.compiler.symbols.SymbolTableEntryBase)
comment92.text=\n\ \ \ \ \ \ \ Jump\ short/near\ if\ less\n
comment93.params=entry
comment93.target=void\ jge(jx.compiler.symbols.SymbolTableEntryBase)
comment93.text=\n\ \ \ \ \ \ \ Jump\ short/near\ if\ greater\ or\ equal\n
comment94.params=entry
comment94.target=void\ jg(jx.compiler.symbols.SymbolTableEntryBase)
comment94.text=\n\ \ \ \ \ \ \ Jump\ short/near\ if\ greater\n
comment95.params=entry
comment95.target=void\ jle(jx.compiler.symbols.SymbolTableEntryBase)
comment95.text=\n\ \ \ \ \ \ \ Jump\ short/near\ if\ less\ or\ equal\n
comment96.params=entry
comment96.target=void\ ja(jx.compiler.symbols.SymbolTableEntryBase)
comment96.text=\n\ \ \ \ \ \ \ Jump\ short/near\ if\ unsigned\ greater\n
comment97.params=entry
comment97.target=void\ jae(jx.compiler.symbols.SymbolTableEntryBase)
comment97.text=\n\ \ \ \ \ \ \ Jump\ short/near\ if\ unsigned\ greater\ or\ equal\n
comment98.params=rel
comment98.target=void\ js(int)
comment98.text=\n\ \ \ \ \ \ \ Jump\ short/near\ if\ sign\n
comment99.params=rel
comment99.target=void\ jmp(int)
comment99.text=\n\ \ \ \ \ \ \ Jump\ short/near\ \n
numComments=163
