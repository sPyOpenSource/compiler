#BlueJ class context
comment0.target=BinaryCodeDynamicARM
comment1.params=
comment1.target=BinaryCodeDynamicARM()
comment10.params=entry
comment10.target=void\ call(jx.compiler.symbols.SymbolTableEntryBase)
comment10.text=\n\ \ \ \ \ \ \ Insert\ call\ near\ (Symbol)\ (1\ clks)\n\ @param\ entry\n
comment100.params=value
comment100.target=void\ insertConst4(int)
comment100.text=\ \n\ \ \ \ Insert\ a\ four\ byte\ constant\ \n
comment101.params=ncIndex\ value
comment101.target=void\ insertConst4At(int,\ int)
comment102.params=entry
comment102.target=void\ insertConst4(jx.compiler.symbols.SymbolTableEntryBase)
comment102.text=\ \n\ \ \ \ Insert\ a\ four\ byte\ constant\ with\ an\ unknown\ value.\ \n\ \ \ \ (must\ be\ resolved\ before\ the\ code\ is\ installed)\ \n
comment103.params=value
comment103.target=boolean\ is8BitValue(int)
comment104.params=entry
comment104.target=void\ insertConst0(jx.compiler.symbols.SymbolTableEntryBase)
comment104.text=\ \n\ \ \ \ Insert\ a\ 0\ byte\ constant\ with\ an\ unknown\ value.\ \n\ \ \ \ (contains\ information\ about\ current\ code\ position,\ i.e.,\ a\ stack\ map)\ \n
comment105.params=
comment105.target=void\ alignCode()
comment105.text=\n\ \ \ \ \ \ \ Intel\ Architecture\ Optimization.\ Reference\ Manual\ (chapter\ 2,page\ 11)\n\ \ \ \ \ \ \ "Pentium\ II\ and\ III\ processors\ have\ a\ cache\ line\ size\ of\ 32\ byte.\n\ \ \ \ \ \ \ Since\ the\ instruction\ prefetch\ buffers\ fetch\ 16-byte\ boundaries,\n\ \ \ \ \ \ \ code\ alignment\ has\ a\ direct\ impact\ on\ prefetch\ buffer\ efficiency"\n\ \ \ \ \ \ \ \n\ Loop\ entry\ labels\ should\ be\ 16-byte-aligned\ when\ less\ then\ \n\ \ \ \ \ \ \ eight\ byte\ away\ from\ a\ 16-byte\ boundary.\n\ \ \ \ \ \ \ \n\ Labels\ that\ follow\ an\ unconditional\ branch\ of\ function\ call\n\ \ \ \ \ \ \ should\ be\ aligend\ as\ above.\n\ \ \ \ \ \ \ \n\ Labels\ that\ follow\ a\ conditional\ branch\ need\ _not_\ be\ aligned.\n
comment106.params=jumpObject
comment106.target=void\ addJumpTarget(jx.compiler.symbols.UnresolvedJump)
comment106.text=\ \n\ \ \ \ Initialized\ the\ target\ position\ of\ 'jumpObject'.\ \n\ \ \ \ (Call\ insertConst4()\ for\ corresponding\ jump\ instruction)\ \n
comment107.params=
comment107.target=void\ alignIP()
comment108.params=
comment108.target=void\ alignIP_4_Byte()
comment109.params=
comment109.target=void\ alignIP_16_Byte()
comment11.params=
comment11.target=void\ ret()
comment11.text=\n\ \ \ \ \ \ \ Insert\ return\n
comment110.params=
comment110.target=void\ alignIP_32_Byte()
comment111.params=handler
comment111.target=void\ addExceptionTarget(jx.compiler.symbols.UnresolvedJump)
comment112.params=entry
comment112.target=void\ makeRelative(jx.compiler.symbols.SymbolTableEntryBase)
comment112.text=\ \n\ \ \ \ Make\ a\ symbol\ table\ entry\ relative.\ \n\ \ \ \ If\ you\ use\ insertConst4(),\ this\ class\ assumes\ that\ \n\ \ \ \ the\ value\ to\ be\ inserted\ is\ absolute.\ But\ if\ the\ \n\ \ \ \ inserted\ value\ is\ a\ jump\ offset\ it\ is\ relative\ to\ \n\ \ \ \ the\ instruction\ pointer\ of\ the\ next\ instruction.\ \n\ \ \ \ That\ is\ what\ you\ can\ tell\ the\ compiler\ with\ this\ \n\ \ \ \ method.\ \n
comment113.params=
comment113.target=void\ endInstr()
comment113.text=\n\ \ \ \ \ \ \ Called\ after\ each\ instruction.\ \n
comment114.params=
comment114.target=void\ finishCode()
comment115.params=codeBase
comment115.target=void\ resolve(int)
comment115.text=\ \n\ \ \ \ Apply\ all\ resolveable\ symbol\ table\ entries.\n\ \ \ \ (e.g.\ insert\ jump\ offsets\ ....)\n\ \ \ \ After\ calling\ this\ method,\ the\ vector\ 'symbolTable'\ \n\ \ \ \ contains\ all\ symbol\ table\ entries\ that\ are\ not\ resolveable.\n\ \ \ \ If\ you\ want\ to\ install\ the\ compiled\ code\ after\ calling\ this\ \n\ \ \ \ method,\ this\ vector\ should\ be\ empty.\ \n\ @param\ codeBase\n
comment116.params=reg
comment116.target=java.lang.String\ regToString(int)
comment117.params=handler
comment117.target=void\ addExceptionRangeStart(NCExceptionHandler)
comment118.params=handler
comment118.target=void\ addExceptionRangeEnd(NCExceptionHandler)
comment119.params=handler
comment119.target=void\ addExceptionHandler(NCExceptionHandler)
comment119.text=\n\ \ \ \ add\ a\ start\ of\ an\ exception\ handler.\n\ @param\ handler\n
comment12.params=
comment12.target=void\ cli()
comment12.text=\n\ \ \ \ \ \ \ clear\ interrupt\ flag\ (7\ clks)\n
comment120.params=
comment120.target=NCExceptionHandler[]\ getExceptionHandlers()
comment120.text=\n\ \ \ \ return\ an\ array\ of\ all\ exception\ handlers\ of\ this\ \n\ \ \ \ method.\ (these\ handlers\ contain\ the\ native\ code\ indices\ \n\ \ \ \ of\ the\ range\ start,\ range\ end\ and\ of\ the\ handler\ start\ \n\ @return\n
comment121.params=firstByte\ stopByte
comment121.target=java.lang.String\ getBinaryCodeAsHex(int,\ int)
comment122.params=
comment122.target=java.lang.String\ getBinaryCodeAsHex()
comment123.params=firstByte\ stopByte
comment123.target=java.lang.String\ getBinaryCodeAsAssembler(int,\ int)
comment124.params=
comment124.target=java.lang.String\ getBinaryCodeAsAssembler()
comment125.params=instr\ arg1\ arg2
comment125.target=void\ printInstr(java.lang.String,\ java.lang.String,\ jx.compiler.symbols.SymbolTableEntryBase)
comment126.params=instr\ arg1\ arg2
comment126.target=void\ printInstr(java.lang.String,\ jx.compiler.symbols.SymbolTableEntryBase,\ java.lang.String)
comment127.params=instr\ arg1\ arg2\ arg3
comment127.target=void\ printInstr(java.lang.String,\ java.lang.String,\ jx.compiler.symbols.SymbolTableEntryBase,\ java.lang.String)
comment128.params=instr
comment128.target=void\ printInstr(java.lang.String)
comment129.params=instr\ arg1\ arg2
comment129.target=void\ printInstr(java.lang.String,\ java.lang.String,\ java.lang.String)
comment13.params=opr
comment13.target=void\ decb(Opr)
comment13.text=\n\ \ \ \ \ \ \ decrement\ byte\ value\ by\ 1\ (1/3\ clks)\n\ @param\ opr\n
comment130.params=instr\ arg1
comment130.target=void\ printInstr(java.lang.String,\ jx.compiler.symbols.SymbolTableEntryBase)
comment131.params=entry
comment131.target=void\ printJumpTarget(jx.compiler.symbols.UnresolvedJump)
comment132.params=value
comment132.target=void\ printHexByte(int)
comment133.params=value
comment133.target=void\ printHexInt(int)
comment134.params=
comment134.target=void\ printInstructions()
comment135.params=out
comment135.target=void\ printGASInstructions(java.io.PrintStream)
comment136.params=bcPosition
comment136.target=void\ startBC(int)
comment137.params=
comment137.target=void\ endBC()
comment138.params=
comment138.target=java.util.ArrayList\ getInstructionTable()
comment14.params=ref
comment14.target=void\ decl(Ref)
comment14.text=\n\ \ \ \ \ \ \ decrement\ long\ value\ by\ 1\ (1/3\ clks)\n\ @param\ ref\n
comment15.params=reg
comment15.target=void\ decl(Reg)
comment15.text=\ \n\ \ \ \ \ \ \ decrement\ register\ by\ 1\ (1\ clks)\n\ @param\ reg\n
comment16.params=reg
comment16.target=void\ push(Reg)
comment16.text=\n\ \ \ \ \ \ \ Insert\ a\ pushl(reg)\n\ @param\ reg\n
comment17.params=ref
comment17.target=void\ push(Ref)
comment18.params=immd
comment18.target=void\ push(int)
comment19.params=entry
comment19.target=void\ push(jx.compiler.symbols.SymbolTableEntryBase)
comment2.params=
comment2.target=int\ getCurrentIP()
comment2.text=\n\ \ \ \ public\ jx.jit.nativecode.BinaryCode\ getOldBinaryCode()\ {\n\n\ \ \ \ Enumeration\ enum\ \=\ symbolTable.elements();\ \n\ \ \ \ Vector\ unresolvedEntries\ \=\ new\ Vector();\ \n\ \ \ \ while(enum.hasMoreElements())\ {\n\ \ \ \ \ \ \ \ SymbolTableEntryBase\ entry\ \=\ (SymbolTableEntryBase)enum.nextElement();\n\ \ \ \ \ \ \ \ if\ (entry\ instanceof\ IntValueSTEntry)\ {\n\ \ \ \ \ \ \ \ ((IntValueSTEntry)entry).applyValue(code);\n\ \ \ \ \ \ \ \ //entry.apply(code,\ codeBase);\n\ \ \ \ \ \ \ \ }\ else\ {\n\ \ \ \ \ \ \ \ unresolvedEntries.addElement(entry);\ \n\ \ \ \ \ \ \ \ }\n\ \ \ \ }\n\ \ \ \ symbolTable\ \=\ unresolvedEntries;\ \n\n\ \ \ \ \ \ return\ new\ jx.jit.nativecode.BinaryCode(code,\ ip,\ symbolTable);\ \n\ \ \ \ }\n
comment20.params=
comment20.target=void\ pushfl()
comment21.params=
comment21.target=void\ pushal()
comment21.text=\n\ \ \ \ \ \ \ push\ all\ general\ registers\n\ \ \ \ \ \ \ (eax,ecx,edx,ebx,esp,ebp,esi,edi)\ \n\ \ \ \ \ \ \ (5\ clks)\n
comment22.params=reg
comment22.target=void\ pop(Reg)
comment22.text=\ \n\ \ \ \ \ \ \ Insert\ a\ popl(reg)\n\ @param\ reg\n
comment23.params=
comment23.target=void\ popfl()
comment23.text=\n\ \ \ \ \ \ \ pop\ stack\ into\ eflags\ register\ (4\ clks)\n
comment24.params=
comment24.target=void\ popal()
comment24.text=\n\ \ \ \ \ \ \ pop\ all\ general\ register\n
comment25.params=
comment25.target=void\ lock()
comment25.text=\ \n\ \ \ \ \ \ lock\ prefix\n
comment26.params=src\ des
comment26.target=void\ sub(Opr,\ Reg)
comment26.text=\n\ \ \ \ \ \ \ Integer\ Subtraction\n\ @param\ src\n\ @param\ des\n
comment27.params=src\ des
comment27.target=void\ sub(Reg,\ Ref)
comment28.params=immd\ des
comment28.target=void\ sub(int,\ Opr)
comment29.params=entry\ des
comment29.target=void\ sub(jx.compiler.symbols.SymbolTableEntryBase,\ Opr)
comment3.params=
comment3.target=void\ realloc()
comment30.params=src\ des
comment30.target=void\ sbbl(Opr,\ Reg)
comment30.text=\n\ \ \ \ \ \ \ Integer\ Subtraction\ with\ Borrow\n\ @param\ src\n\ @param\ des\n
comment31.params=src\ des
comment31.target=void\ sbbl(Reg,\ Ref)
comment32.params=src
comment32.target=void\ mul(Opr)
comment32.text=\n\ \ \ \ \ \ \ Integer\ Unsigned\ Multiplication\ of\ eax\ \ (10\ clk)\n\ @param\ src\n
comment33.params=src\ des
comment33.target=void\ smull(Opr,\ Reg)
comment33.text=\n\ \ \ \ \ \ \ Integer\ Signed\ Multiplication\ (10\ clk)\n\ @param\ src\n\ @param\ des\n
comment34.params=immd\ des
comment34.target=void\ smull(int,\ Reg)
comment34.text=imull(Reg\ src,\ Ref\ des)\ no\ x86-code
comment35.params=immd\ src\ des
comment35.target=void\ smull(int,\ Opr,\ Reg)
comment36.params=entry\ des
comment36.target=void\ smull(jx.compiler.symbols.SymbolTableEntryBase,\ Reg)
comment37.params=opr\ reg
comment37.target=void\ lea(Opr,\ Reg)
comment37.text=\ \n\ \ \ \ lea\ Load\ Effective\ Address\ (1\ clk)\n\ \ \n\ \ \ \ \ \ \ \ m\ \=\ index\ *\ [0,1,2,4,8]\ +\ base\ +\ disp\n\n\ \ \ \ \ \ \ \ base.disp(disp,index,[0,1,2,4,8])\n\ @param\ opr\ \ \ \ \ \ \ \ \n\ @param\ reg\ \ \ \ \ \ \ \ \n
comment38.params=immd\ des
comment38.target=void\ lsl(int,\ Opr)
comment38.text=\n\ \ \ \ \ \ \ SHL/SAL\ Shift\ left\ (1/3\ clks)\n\ @param\ immd\n\ @param\ des\n
comment39.params=des
comment39.target=void\ lsl(Opr)
comment39.text=\n\ \ \ \ \ \ \ SHL/SAL\ Shift\ left\ by\ %cl\ (4\ clks)\n\ @param\ des\n
comment4.params=requiredSpace
comment4.target=void\ realloc(int)
comment4.text=\ \n\ Realloc\ memory\ in\ the\ byte\ code\ array.\ \n\ After\ calling\ this\ method,\ there\ are\ at\ least\ \n\ \ \ \ '*\ requiredSpace'\ free\ bytes\ in\ the\ array.\ \n\ @param\ requiredSpace\n
comment40.params=immd\ des
comment40.target=void\ lsr(int,\ Opr)
comment40.text=\n\ \ \ \ \ \ \ SHR\ Shift\ right\ (1/3\ clks)\n\ @param\ immd\n\ @param\ des\n
comment41.params=entry\ des
comment41.target=void\ lsr(jx.compiler.symbols.SymbolTableEntryBase,\ Opr)
comment42.params=des
comment42.target=void\ shrl(Opr)
comment42.text=\n\ \ \ \ \ \ \ SHL/SAL\ Shift\ left\ by\ %cl\ (4\ clks)\n\ @param\ des\n
comment43.params=immd\ des
comment43.target=void\ sarl(int,\ Opr)
comment43.text=\n\ \ \ \ \ \ \ SAR\ Shift\ right\ (signed)\ (1/3\ clks)\n\ @param\ immd\n\ @param\ des\n
comment44.params=des
comment44.target=void\ sarl(Opr)
comment44.text=\n\ \ \ \ \ \ \ SAR\ Shift\ right\ by\ %cl\ (signed)\ (4\ clks)\n\ @param\ des\n
comment45.params=src
comment45.target=void\ dvf(Opr)
comment45.text=\n\ \ \ \ \ \ \ DIV\ Signed\ Divide\n\ @param\ src\n
comment46.params=src\ des
comment46.target=void\ add(Opr,\ Reg)
comment46.text=\n\ \ \ \ \ \ \ Add\n\ @param\ src\n\ @param\ des\n
comment47.params=src\ des
comment47.target=void\ add(Reg,\ Ref)
comment48.params=immd\ des
comment48.target=void\ add(int,\ Opr)
comment49.params=entry\ des
comment49.target=void\ add(jx.compiler.symbols.SymbolTableEntryBase,\ Opr)
comment5.params=value
comment5.target=void\ insertByte(int)
comment5.text=\ \n\ \ \ \ Insert\ a\ single\ byte\n
comment50.params=src\ des
comment50.target=void\ and(Opr,\ Reg)
comment50.text=\n\ \ \ \ \ \ \ And\ (1/3\ clks)\n
comment51.params=src\ des
comment51.target=void\ and(Reg,\ Ref)
comment52.params=immd\ des
comment52.target=void\ and(int,\ Opr)
comment53.params=entry\ des
comment53.target=void\ and(jx.compiler.symbols.SymbolTableEntryBase,\ Opr)
comment54.params=src\ des
comment54.target=void\ orr(Opr,\ Reg)
comment54.text=\n\ \ \ \ \ \ \ Or\ (1/3\ clks)\n
comment55.params=src\ des
comment55.target=void\ orr(Reg,\ Ref)
comment56.params=immd\ des
comment56.target=void\ orr(int,\ Opr)
comment57.params=entry\ des
comment57.target=void\ orr(jx.compiler.symbols.SymbolTableEntryBase,\ Opr)
comment58.params=src\ des
comment58.target=void\ xorl(Opr,\ Reg)
comment58.text=\n\ \ \ \ \ \ \ Or\ (1/3\ clks)\n
comment59.params=src\ des
comment59.target=void\ xorl(Reg,\ Ref)
comment6.params=entry
comment6.target=void\ insertByte(jx.compiler.symbols.SymbolTableEntryBase)
comment60.params=immd\ des
comment60.target=void\ xorl(int,\ Opr)
comment61.params=entry\ des
comment61.target=void\ xorl(jx.compiler.symbols.SymbolTableEntryBase,\ Opr)
comment62.params=opr
comment62.target=void\ notl(Opr)
comment62.text=\n\ \ \ \ \ \ \ Not\ (1/3\ clks)\n
comment63.params=opr
comment63.target=void\ neg(Opr)
comment63.text=\n\ \ \ \ \ \ \ Neg\ (1/3\ clks)\n
comment64.params=src\ des
comment64.target=void\ adc(Opr,\ Reg)
comment64.text=\n\ \ \ \ \ \ \ Add\ with\ Carry\n
comment65.params=src\ des
comment65.target=void\ adc(Reg,\ Ref)
comment66.params=src\ des
comment66.target=void\ cmp(Opr,\ Reg)
comment66.text=\n\ \ \ \ \ \ \ Compare\ Two\ Operands\n
comment67.params=src\ des
comment67.target=void\ cmp(Reg,\ Ref)
comment68.params=immd\ des
comment68.target=void\ cmp(int,\ Opr)
comment69.params=entry\ des
comment69.target=void\ cmp(jx.compiler.symbols.SymbolTableEntryBase,\ Opr)
comment7.params=reg\ rm
comment7.target=void\ insertModRM(int,\ Opr)
comment7.text=\n\ \ \ \ \ \ \ Insert\ ModRM\ and\ SIB\ byte\ \n
comment70.params=des
comment70.target=void\ sete(Opr)
comment70.text=\n\ @param\ des\n
comment71.params=des
comment71.target=void\ setne(Opr)
comment72.params=nr
comment72.target=void\ intr(int)
comment73.params=rel
comment73.target=void\ je(int)
comment73.text=\n\ \ \ \ \ \ \ Jump\ short/near\ if\ equal\n
comment74.params=entry
comment74.target=void\ je(jx.compiler.symbols.SymbolTableEntryBase)
comment75.params=rel
comment75.target=void\ jne(int)
comment75.text=\n\ \ \ \ \ \ \ Jump\ short/near\ if\ not\ equal\n
comment76.params=entry
comment76.target=void\ jne(jx.compiler.symbols.SymbolTableEntryBase)
comment77.params=entry
comment77.target=void\ jnae(jx.compiler.symbols.SymbolTableEntryBase)
comment78.params=entry
comment78.target=void\ jl(jx.compiler.symbols.SymbolTableEntryBase)
comment78.text=\n\ \ \ \ \ \ \ Jump\ short/near\ if\ less\n
comment79.params=entry
comment79.target=void\ jge(jx.compiler.symbols.SymbolTableEntryBase)
comment79.text=\n\ \ \ \ \ \ \ Jump\ short/near\ if\ greater\ or\ equal\n
comment8.params=reg\ rm
comment8.target=void\ insertModRM(Reg,\ Opr)
comment80.params=entry
comment80.target=void\ jg(jx.compiler.symbols.SymbolTableEntryBase)
comment80.text=\n\ \ \ \ \ \ \ Jump\ short/near\ if\ greater\n
comment81.params=entry
comment81.target=void\ jle(jx.compiler.symbols.SymbolTableEntryBase)
comment81.text=\n\ \ \ \ \ \ \ Jump\ short/near\ if\ less\ or\ equal\n
comment82.params=entry
comment82.target=void\ ja(jx.compiler.symbols.SymbolTableEntryBase)
comment82.text=\n\ \ \ \ \ \ \ Jump\ short/near\ if\ unsigned\ greater\n
comment83.params=entry
comment83.target=void\ jae(jx.compiler.symbols.SymbolTableEntryBase)
comment83.text=\n\ \ \ \ \ \ \ Jump\ short/near\ if\ unsigned\ greater\ or\ equal\n
comment84.params=rel
comment84.target=void\ js(int)
comment84.text=\n\ \ \ \ \ \ \ Jump\ short/near\ if\ sign\n
comment85.params=rel
comment85.target=void\ b(int)
comment85.text=\n\ \ \ \ \ \ \ Jump\ short/near\ \n
comment86.params=des
comment86.target=void\ b(Opr)
comment87.params=entry
comment87.target=void\ b(jx.compiler.symbols.SymbolTableEntryBase)
comment88.params=index\ tables
comment88.target=void\ b(Reg,\ jx.compiler.symbols.SymbolTableEntryBase[])
comment89.params=src\ des
comment89.target=void\ mov(Opr,\ Reg)
comment89.text=\n\ \ \ \ \ \ \ Move\ 32\ Bit\ Data\n
comment9.params=opr
comment9.target=void\ call(Opr)
comment9.text=\n\ \ \ \ \ \ \ Insert\ call\ near\ indirect\ (reg/mem)\ (2\ clks)\n\ @param\ opr\n
comment90.params=src\ des
comment90.target=void\ mov(Reg,\ Ref)
comment91.params=immd\ des
comment91.target=void\ mov(int,\ Opr)
comment92.params=entry\ des
comment92.target=void\ mov(jx.compiler.symbols.SymbolTableEntryBase,\ Opr)
comment93.params=src\ des
comment93.target=void\ movzwl(Opr,\ Reg)
comment93.text=\n\ \ \ \ \ \ \ Move\ with\ Zero-Extend\ (short)\ (3\ clks)\n
comment94.params=
comment94.target=void\ nop()
comment94.text=\n\ \ \ \ \ \ \ No\ Operation\ (1\ clks)\n
comment95.params=
comment95.target=void\ wrmsr()
comment95.text=\n\ \ \ \ \ \ \ write\ to\ model\ specific\ register\ (30-45\ clks)\n\n\ \ \ \ \ \ \ ecx\ \ |\ register\n\ \ \ \ \ \ \ \=\=\=\=\=\=\=\=\=\=\=\=\=\=\=\=\=\=\=\=\=\=\=\=\=\=\=\=\=\n\ \ \ \ \ \ \ 0x00\ |\ machine\ check\ address\n\ \ \ \ \ \ \ 0x01\ |\ machine\ check\ type\n\ \ \ \ \ \ \ \=\=\=\=\=\=\=\=\=\=\=\=\=\=\=\=\=\=\=\=\=\=\=\=\=\=\=\=\=\n\ \ \ \ \ \ \ 0x10\ |\ time\ stamp\ counter\n\ \ \ \ \ \ \ 0x11\ |\ control\ and\ event\ select\n\ \ \ \ \ \ \ 0x12\ |\ counter\ 0\n\ \ \ \ \ \ \ 0x13\ |\ counter\ 1\n\n
comment96.params=
comment96.target=void\ rdmsr()
comment96.text=\n\ \ \ \ \ \ \ read\ from\ model\ specific\ register\ (20-24\ clks)\n\n\ \ \ \ \ \ \ see\ wrmsr()\ for\ register\ selection\n
comment97.params=src\ des
comment97.target=void\ test(Opr,\ Reg)
comment97.text=\n\ \ \ \ \ \ \ test\ -\ logical\ compare\ (1/2\ clks)\n
comment98.params=immd\ des
comment98.target=void\ test(int,\ Opr)
comment99.params=value
comment99.target=void\ insertConst1(int)
comment99.text=\ \n\ \ \ \ Insert\ a\ single\ byte\ constant\ \n
numComments=139
