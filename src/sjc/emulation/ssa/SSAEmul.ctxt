#BlueJ class context
comment0.target=SSAEmul
comment0.text=\n\ Class\ representing\ the\ SSA\ emulator\n\ \n\ @author\ Patrick\ Schmidt,\ Stefan\ Frenz\n\ @version\ 101101\ adopted\ changed\ I_DEREF\n\ \ version\ 100927\ fixed\ unsignedness\ of\ chars\n\ \ version\ 100412\ added\ killRegOnJmp2\ to\ support\ two\ registers\ to\ be\ killed\ on\ jump\n\ \ version\ 090717\ added\ stack\ extreme\ check\ instruction\ I_STKCHK\n\ \ version\ 090626\ fixed\ base\ pointer\ relative\ addressing\n\ \ version\ 090207\ added\ copyright\ notice\n\ \ version\ 081021\ adopted\ changes\ in\ I/O-read/write\ and\ compare\n\ \ version\ 080701\ updated\ endless-loop-detection\ (added\ flowhints\ inhibit\ old\ algorithm)\n\ \ version\ 080616\ added\ support\ for\ language\ throwables\n\ \ version\ 080508\ added\ support\ for\ flow\ hints\n\ \ version\ 080207\ adopted\ changes\ in\ semantics\ of\ I_IVOF\ to\ hold\ all\ parameters\n\ \ version\ 080203\ added\ support\ for\ method\ inlining\ and\ floating\ point\ arithmetic\n\ \ version\ 080122\ better\ error\ message\ for\ invalidly\ killed\ registers\n\ \ version\ 080104\ extended\ insAlloc\ to\ support\ allocation\ of\ low-numbered\ regrange-defined\ registers\n\ \ version\ 070917\ pre-initialization\ of\ stack\ variables\ with\ "0"\n\ \ version\ 070913\ adopted\ changes\ in\ stack\ frame\ building\n\ \ version\ 070721\ changed\ comments\ \n\ \ version\ 070501\ fixed\ error\ message\ in\ getMnemonicList,\ fixed\ parameter\ in\ I_CALLim_p\n\ \ version\ 070114\ added\ output\ of\ parSize\ for\ calls\n\ \ version\ 061203\ bugfix\ in\ disassembly\ of\ assign\n\ \ version\ 061202\ adopted\ change\ of\ genCall\n\ \ version\ 061109\ added\ bound-condition\ for\ int\ (needed\ for\ struct-array-bounds)\n\ \ version\ 060714\ changed\ bound-semantics\n\ \ version\ 060620\ added\ kill-on-jump\n\ \ version\ 060613\ several\ bugfixes\n\ \ version\ 060608\ initial\ version\n
comment1.params=ir
comment1.target=SSAEmul(sjc.real.Real)
comment1.text=\n\ Constructor\ for\ SSAEmul\n\ @param\ ir\ Real\ interface\ implementation\ for\ floating\ point\ support\n
comment10.params=imI\ para\ inline
comment10.target=boolean\ insLeave(int,\ int,\ boolean)
comment10.text=\n\ Method\ to\ process\ the\ leave\ instruction.\ Return\ and\ stack\ pointer\ \n\ adjustment.\n\ SP\ <-\ SP\ +\ imI\n\ IP\ <-\ [SP]\n\ SP\ <-\ SP\ +\ relocBytes\ +\ para\ \n\ \ \ \ \ \ \ \ (Ruecksprungadresse\ +\ uebergebene\ Parameter\ abraeumen)\n\ @param\ imI\ variable\ size\ add\ to\ stack\ pointer\n\ @param\ para\ return\ size\n\ @return\ true\ if\ the\ operation\ succeeds,\ false\ otherwise\n
comment11.params=reg0\ size\ para
comment11.target=boolean\ insLoadImI(int,\ int,\ int)
comment11.text=\n\ Method\ to\ process\ the\ load\ immediate\ int\ instruction.\n\ @param\ reg0\ the\ destination\ register\n\ @param\ size\ size\ of\ register\ (has\ to\ match\ declared\ type,\ which\ is\ the\ size\n\ of\ the\ already\ allocated\ register)\n\ @param\ para\ the\ value\ to\ load\ (byte,\ short,\ int)\n\ @return\ true\ if\ the\ operation\ succeeds,\ false\ otherwise\n
comment12.params=reg0\ size\ imL
comment12.target=boolean\ insLoadImL(int,\ int,\ long)
comment12.text=\n\ Method\ to\ process\ the\ load\ immediate\ long\ instruction\n\ @param\ reg0\ the\ destination\ register\ (has\ to\ be\ long\ sized)\n\ @param\ imL\ the\ long\ value\ to\ load\n\ @return\ true\ if\ the\ operation\ succeeds,\ false\ otherwise\n
comment13.params=reg0\ imP
comment13.target=boolean\ insLoadImP(int,\ int)
comment14.params=reg0\ size
comment14.target=boolean\ insLoadNP(int,\ int)
comment14.text=\n\ Method\ to\ process\ the\ load\ np\ instruction\ -\ i.e.\ to\ load\ a\ null\ pointer\n\ @param\ reg0\ destination\ register\n\ @param\ size\ -1\ for\ pointer,\ -2\ for\ double\ pointer,\ has\ to\ match\ declared\n\ type\n\ @return\ true\ if\ the\ operation\ succeeds,\ false\ otherwise\n
comment15.params=reg0\ reg1\ rela
comment15.target=boolean\ insLoadAddr(int,\ int,\ int)
comment15.text=\n\ Method\ to\ process\ the\ load\ addr\ instruction\n\ reg0\ <-\ reg1\ +\ rela\n\ @param\ reg0\ the\ destination\ register\ -\ has\ to\ be\ pointer\n\ @param\ reg1\ a\ base\ register\ -\ has\ to\ be\ a\ pointer\n\ @param\ rela\ offset\ relative\ to\ reg1\n\ @return\ true\ if\ the\ operation\ succeeds,\ false\ otherwise\n
comment16.params=reg0\ reg1\ size
comment16.target=boolean\ insLoadVal(int,\ int,\ int)
comment16.text=\n\ Method\ to\ process\ the\ load\ val\ instruction\n\ reg0\ <-\ [reg1].size\n\ @param\ reg0\ the\ destination\ register,\ has\ to\ be\ sized\ size\n\ @param\ reg1\ the\ register\ containing\ the\ source\ address\ (has\ to\ be\ a\ \n\ pointer)\n\ @param\ size\ the\ size\ of\ reg0\n\ @return\ true\ if\ the\ operation\ succeeds,\ false\ otherwise\n
comment17.params=reg0\ reg1\ size\ para
comment17.target=boolean\ insConv(int,\ int,\ int,\ int)
comment17.text=\n\ Method\ to\ process\ the\ conv\ instruction.\ Convert\ the\ value\ of\ register\ 1\ of\n\ type\ para\ to\ the\ type\ size\ and\ store\ it\ in\ register\ 0\n\ @param\ reg0\ the\ destination\ register\n\ @param\ reg1\ the\ source\ register\n\ @param\ size\ the\ destination\ size\n\ @param\ para\ the\ source\ size\n\ @return\ true\ if\ the\ operation\ succeeds,\ false\ otherwise\n
comment18.params=reg0\ reg1\ size
comment18.target=boolean\ insCopy(int,\ int,\ int)
comment18.text=\n\ Method\ to\ process\ the\ copy\ instruction\n\ @param\ reg0\ the\ destination\ register\n\ @param\ reg1\ the\ source\ register\n\ @param\ size\ the\ size\ of\ both\ registers\ to\ check\n\ @return\ true\ if\ the\ operation\ succeeds,\ false\ otherwise\n
comment19.params=size\ imI
comment19.target=boolean\ insPushImI(int,\ int)
comment19.text=\n\ Method\ to\ process\ the\ push\ immediate\ int\ instruction\n\ SP\ <-\ (SP\ -\ size)\ &\ ~stackClearBits\n\ [SP]\ <-\ imI\n\ @param\ size\ the\ size\ of\ the\ value\ to\ store\ on\ the\ stack\n\ @param\ imI\ the\ value\n\ @return\ true\ if\ the\ operation\ succeeds,\ false\ otherwise\n
comment2.params=cond
comment2.target=java.lang.String\ getJump(int)
comment2.text=\n\ Method\ to\ decode\ a\ jump\n\ @param\ cond\ the\ given\ condition\n\ @return\ a\ String\ representation\ of\ the\ jump\n
comment20.params=imL
comment20.target=boolean\ insPushImL(long)
comment20.text=\n\ Method\ to\ process\ the\ push\ immediate\ long\ instruction\n\ SP\ <-\ (SP\ -\ 8)\ &\ ~stackClearBits\n\ [SP]\ <-\ imL\n\ @param\ imL\ the\ long\ value\ to\ store\ on\ the\ stack\n\ @return\ true\ if\ the\ operation\ succeeds,\ false\ otherwise\n
comment21.params=
comment21.target=boolean\ insPushNP()
comment21.text=\n\ Method\ to\ process\ the\ push\ np\ instruction\ -\ i.\ e.\ to\ push\ a\ null\ pointer\ on\n\ the\ stack\n\ SP\ <-\ (SP\ -\ relocBytes)\ &\ ~stackClearBits\n\ [SP]\ <-\ 0\n\ @return\ true\ if\ the\ operation\ succeeds,\ false\ otherwise\n
comment22.params=reg0\ size
comment22.target=boolean\ insPush(int,\ int)
comment22.text=\n\ Method\ to\ process\ the\ push\ instruction\n\ adjust\ SP\n\ [SP]\ <-\ reg0.size\n\ @param\ reg0\ the\ register\ to\ push\n\ @param\ size\ the\ size\ of\ the\ register\n\ @return\ true\ if\ the\ operation\ succeeds,\ false\ otherwise\n
comment23.params=reg0\ size
comment23.target=boolean\ insPop(int,\ int)
comment23.text=\n\ Method\ to\ process\ the\ pop\ instruction\n\ reg0\ <-\ [SP].size\n\ adjust\ SP\n\ @param\ reg0\ the\ destination\ register\n\ @param\ size\ the\ size\ of\ register\ 0\n\ @return\ true\ if\ the\ operation\ succeeds,\ false\ otherwise\n
comment24.params=reg0\ size\ para
comment24.target=boolean\ insSave(int,\ int,\ int)
comment24.text=\n\ Save\ register\ before\ call\n\ @param\ reg0\ register\ to\ save\n\ @param\ size\ size\ of\ the\ register\ to\ save\n\ @param\ para\ if\ 0\ then\ ignore,\ if\ 1\ push\ reg0\ on\ the\ stack\n\ @return\n
comment25.params=reg0\ size\ para
comment25.target=boolean\ insRest(int,\ int,\ int)
comment25.text=\n\ Restore\ register\ after\ call\n\ @param\ reg0\ register\ to\ restore\n\ @param\ size\ size\ of\ the\ register\ to\ restore\n\ @param\ para\ if\ 0\ then\ allocate\ register,\ if\ 1\ pop\ reg0\ from\ the\ stack\n\ @return\n
comment26.params=reg0\ reg1\ size
comment26.target=boolean\ insAssign(int,\ int,\ int)
comment26.text=\n\ Method\ to\ process\ the\ assign\ instruction\n\ [reg0]\ <-\ reg1.size\n\ @param\ reg0\ the\ destination\ register,\ has\ to\ be\ pointer\n\ @param\ reg1\ the\ source\ register,\ has\ to\ be\ sized\ size\n\ @param\ size\ the\ size\n\ @return\ true\ if\ the\ operation\ succeeds,\ false\ otherwise\n
comment27.params=reg0\ reg1\ reg2\ size
comment27.target=boolean\ insAnd(int,\ int,\ int,\ int)
comment27.text=\n\ Method\ to\ process\ the\ and\ instruction\n\ reg0\ <-\ reg1\ and\ reg2\n\ @param\ reg0\ the\ destination\ register\n\ @param\ reg1\ the\ first\ operand\n\ @param\ reg2\ the\ second\ operand\n\ @param\ size\ the\ size\ of\ all\ registers\n\ @return\ true\ if\ the\ operation\ succeeds,\ false\ otherwise\n
comment28.params=reg0\ reg1\ reg2\ size
comment28.target=boolean\ insXor(int,\ int,\ int,\ int)
comment28.text=\n\ Method\ to\ process\ the\ xor\ instruction\n\ reg0\ <-\ reg1\ xor\ reg2\n\ @param\ reg0\ the\ destination\ register\n\ @param\ reg1\ the\ first\ operand\n\ @param\ reg2\ the\ second\ operand\n\ @param\ size\ the\ size\ of\ all\ registers\n\ @return\ true\ if\ the\ operation\ succeeds,\ false\ otherwise\n
comment29.params=reg0\ reg1\ reg2\ size
comment29.target=boolean\ insOr(int,\ int,\ int,\ int)
comment29.text=\n\ Method\ to\ process\ the\ or\ instruction\n\ reg0\ <-\ reg1\ or\ reg2\n\ @param\ reg0\ the\ destination\ register\n\ @param\ reg1\ the\ first\ operand\n\ @param\ reg2\ the\ second\ operand\n\ @param\ size\ the\ size\ of\ all\ registers\n\ @return\ true\ if\ the\ operation\ succeeds,\ false\ otherwise\n
comment3.params=typeID
comment3.target=java.lang.String\ getType(int)
comment3.text=\n\ Method\ to\ decode\ the\ size\ of\ a\ register\n\ @param\ typeID\ the\ size\ of\ the\ register\n\ @return\ a\ String\ containing\ the\ type\ of\ the\ register\n
comment30.params=reg0\ reg1\ reg2\ size
comment30.target=boolean\ insAdd(int,\ int,\ int,\ int)
comment30.text=\n\ Method\ to\ process\ the\ add\ instruction\n\ reg0\ <-\ reg1\ add\ reg2\n\ @param\ reg0\ the\ destination\ register\n\ @param\ reg1\ the\ first\ operand\n\ @param\ reg2\ the\ second\ operand\n\ @param\ size\ the\ size\ of\ all\ registers\n\ @return\ true\ if\ the\ operation\ succeeds,\ false\ otherwise\n
comment31.params=reg0\ reg1\ reg2\ size
comment31.target=boolean\ insSub(int,\ int,\ int,\ int)
comment31.text=\n\ Method\ to\ process\ the\ sub\ instruction\n\ reg0\ <-\ reg1\ sub\ reg2\n\ @param\ reg0\ the\ destination\ register\n\ @param\ reg1\ the\ first\ operand\n\ @param\ reg2\ the\ second\ operand\n\ @param\ size\ the\ size\ of\ all\ registers\n\ @return\ true\ if\ the\ operation\ succeeds,\ false\ otherwise\n
comment32.params=reg0\ reg1\ reg2\ size
comment32.target=boolean\ insMul(int,\ int,\ int,\ int)
comment32.text=\n\ Method\ to\ process\ the\ mul\ instruction\n\ reg0\ <-\ reg1\ mul\ reg2\n\ @param\ reg0\ the\ destination\ register\n\ @param\ reg1\ the\ first\ operand\n\ @param\ reg2\ the\ second\ operand\n\ @param\ size\ the\ size\ of\ all\ registers\n\ @return\ true\ if\ the\ operation\ succeeds,\ false\ otherwise\n
comment33.params=reg0\ reg1\ reg2\ size
comment33.target=boolean\ insDiv(int,\ int,\ int,\ int)
comment33.text=\n\ Method\ to\ process\ the\ div\ instruction\n\ reg0\ <-\ reg1\ div\ reg2\n\ @param\ reg0\ the\ destination\ register\n\ @param\ reg1\ the\ first\ operand\n\ @param\ reg2\ the\ second\ operand\n\ @param\ size\ the\ size\ of\ all\ registers\n\ @return\ true\ if\ the\ operation\ succeeds,\ false\ otherwise\n
comment34.params=reg0\ reg1\ reg2\ size
comment34.target=boolean\ insMod(int,\ int,\ int,\ int)
comment34.text=\n\ Method\ to\ process\ the\ mod\ instruction\n\ reg0\ <-\ reg1\ mod\ reg2\n\ @param\ reg0\ the\ destination\ register\n\ @param\ reg1\ the\ first\ operand\n\ @param\ reg2\ the\ second\ operand\n\ @param\ size\ the\ size\ of\ all\ registers\n\ @return\ true\ if\ the\ operation\ succeeds,\ false\ otherwise\n
comment35.params=reg0\ reg1\ reg2\ size
comment35.target=boolean\ insShL(int,\ int,\ int,\ int)
comment35.text=\n\ Method\ to\ process\ the\ ShL\ instruction\n\ reg0\ <-\ reg1.size\ <<\ reg2\n\ @param\ reg0\ the\ destination\ register\n\ @param\ reg1\ the\ source\ value\ to\ shift\n\ @param\ reg2\ the\ bit\ count\ to\ shift\ (must\ be\ integer)\n\ @param\ size\ size\ of\ reg0\ and\ reg1\n\ @return\ true\ if\ the\ operation\ succeeds,\ false\ otherwise\n
comment36.params=reg0\ reg1\ reg2\ size
comment36.target=boolean\ insShRL(int,\ int,\ int,\ int)
comment36.text=\n\ Method\ to\ process\ the\ ShRL\ instruction.\ Logical\ shift\ right\ (zero\ extend)\n\ reg0\ <-\ reg1.size\ >>>\ reg2\n\ @param\ reg0\ the\ destination\ register\n\ @param\ reg1\ the\ first\ operand\n\ @param\ reg2\ the\ second\ operand\n\ @param\ size\ the\ size\ of\ all\ registers\n\ @return\ true\ if\ the\ operation\ succeeds,\ false\ otherwise\n
comment37.params=reg0\ reg1\ reg2\ size
comment37.target=boolean\ insShRA(int,\ int,\ int,\ int)
comment37.text=\n\ Method\ to\ process\ the\ ShRA\ instruction.\ Arithmetical\ shift\ right\ (sign\n\ extend)\n\ reg0\ <-\ reg1.size\ >>\ reg2\n\ @param\ reg0\ the\ destination\ register\n\ @param\ reg1\ the\ first\ operand\n\ @param\ reg2\ the\ second\ operand\n\ @param\ size\ the\ size\ of\ all\ registers\n\ @return\ true\ if\ the\ operation\ succeeds,\ false\ otherwise\n
comment38.params=reg0\ reg1\ size
comment38.target=boolean\ insNot(int,\ int,\ int)
comment38.text=\n\ Method\ to\ process\ the\ Not\ instruction\n\ reg0\ <-\ ~reg1.size\n\ @param\ reg0\ the\ destination\ register\n\ @param\ reg1\ the\ source\ register\n\ @param\ size\ the\ size\ of\ both\ registers\n\ @return\ true\ if\ the\ operation\ succeeds,\ false\ otherwise\n
comment39.params=reg0\ reg1\ size
comment39.target=boolean\ insNeg(int,\ int,\ int)
comment39.text=\n\ Method\ to\ process\ the\ Neg\ instruction\n\ reg0\ <-\ -reg1.size\n\ @param\ reg0\ the\ destination\ register\n\ @param\ reg1\ the\ source\ register\n\ @param\ size\ the\ size\ of\ both\ registers\n\ @return\ true\ if\ the\ operation\ succeeds,\ false\ otherwise\n
comment4.params=cd\ si
comment4.target=boolean\ initArchitecture(int,\ int)
comment4.text=\n\ @see\ Emulator\#initArchitecture(int,\ int,\ int,\ int)\n
comment40.params=reg0\ reg1
comment40.target=boolean\ insBinV(int,\ int)
comment40.text=\n\ Method\ to\ process\ the\ BinV\ instruction.\ Binary\ inversion\n\ reg0\ <-\ \!reg1\n\ size\ has\ to\ be\ one\n\ @param\ reg0\ the\ destination\ register\n\ @param\ reg1\ the\ source\ register\n\ @return\ true\ if\ the\ operation\ succeeds,\ false\ otherwise\n
comment41.params=reg0\ size
comment41.target=boolean\ insIncMem(int,\ int)
comment41.text=\n\ Method\ to\ process\ the\ inc\ mem\ instruction\n\ [reg0]\ <-\ 1\ +\ [reg0].size\n\ @param\ reg0\ the\ memory\ destination\ (reg0\ has\ to\ be\ pointer)\n\ @param\ size\ the\ size\ of\ the\ memory\ location\ to\ increment\n\ @return\ true\ if\ the\ operation\ succeeds,\ false\ otherwise\n
comment42.params=reg0\ size
comment42.target=boolean\ insDecMem(int,\ int)
comment42.text=\n\ Method\ to\ process\ the\ dec\ mem\ instruction\n\ [reg0]\ <-\ 1\ -\ [reg0].size\n\ @param\ reg0\ the\ memory\ destination\ (reg0\ has\ to\ be\ pointer)\n\ @param\ size\ the\ size\ of\ the\ memory\ location\ to\ decrement\n\ @return\ true\ if\ the\ operation\ succeeds,\ false\ otherwise\n
comment43.params=reg0\ rela
comment43.target=boolean\ insCall(int,\ int)
comment43.text=\n\ Method\ to\ process\ the\ call\ instruction.\ Call\ method\ starting\ at\n\ SP\ <-\ (SP\ -\ relocBytes)\ &\ ~stackClearBits\n\ [SP]\ <-\ IP\n\ IP\ <-\ [SReg[1]\ +\ rela]\n\ @param\ rela\ the\ relative\ offset\ to\ SReg[1]\n\ @return\ true\ if\ the\ operation\ succeeds,\ false\ otherwise\n
comment44.params=imP
comment44.target=boolean\ insCallImP(int)
comment45.params=reg0\ rela
comment45.target=boolean\ insCallInd(int,\ int)
comment45.text=\n\ Method\ to\ process\ the\ call\ ind\ instruction\n\ SP\ <-\ (SP\ -\ relocBytes)\ &\ ~stackClearBits\n\ [SP]\ <-\ IP\n\ IP\ <-\ [SReg[1]\ +\ [reg0.upperPtr\ +\ rela]]\n\ @param\ reg0\ register\ with\ double\ pointer\ to\ the\ map\n\ @param\ rela\ the\ relative\ offset\ in\ map\n\ @return\ true\ if\ the\ operation\ succeeds,\ false\ otherwise\n
comment46.params=reg0\ reg1\ size\ para
comment46.target=boolean\ insCmp(int,\ int,\ int,\ int)
comment46.text=\n\ Method\ to\ process\ the\ cmp\ instruction.\ Sets\ the\ jump\ conditions\n\ @param\ reg0\ the\ first\ source\ operand\n\ @param\ reg1\ the\ second\ source\ operand\n\ @param\ size\ the\ size\ of\ the\ operands\n\ @param\ cond\ the\ condition\ for\ the\ next\ jump\n\ @return\ true\ if\ the\ operation\ succeeds,\ false\ otherwise\n
comment47.params=reg0\ reg1\ size\ memLoc
comment47.target=boolean\ insOut(int,\ int,\ int,\ int)
comment47.text=\n\ Method\ to\ process\ the\ out\ instruction.\ IO\ memory\ write\n\ @param\ reg0\ \ \ pointer\n\ @param\ reg1\ \ \ the\ value\ to\ write\n\ @param\ size\ \ \ the\ size\ of\ reg1\n\ @param\ memLoc\ the\ memory\ location\n\ @return\ true\ if\ the\ operation\ succeeds,\ false\ otherwise\n
comment48.params=reg0\ reg1\ size\ memLoc
comment48.target=boolean\ insIn(int,\ int,\ int,\ int)
comment48.text=\n\ Method\ to\ process\ the\ in\ instruction.\ IO\ memory\ read\n\ @param\ reg0\n\ @param\ reg1\n\ @param\ size\n\ @param\ memLoc\n\ @return\ true\ if\ the\ operation\ succeeds,\ false\ otherwise\n
comment49.params=cond\ rela
comment49.target=boolean\ insJump(int,\ int)
comment49.text=\n\ Method\ to\ process\ the\ jump\ instruction\n\ if\ (para)\n\ \ \ IP\ <-\ IP\ +\ rela\n\ @param\ cond\ jump\ condition\ (set\ by\ last\ cmp)\n\ @param\ rela\ the\ offset\ relative\ to\ current\ IP\n\ @return\ true\ if\ the\ operation\ succeeds,\ false\ otherwise\n
comment5.params=regNo\ size\ forWrite
comment5.target=Register\ getRegister(int,\ int,\ boolean)
comment5.text=\n\ Method\ to\ obtain\ the\ register\ corresponding\ to\ the\ given\ number\n\ @param\ regNo\ the\ desired\ register\ number\n\ @return\ an\ instance\ of\ the\ corresponding\ register\n
comment50.params=reg0\ reg1\ rela
comment50.target=boolean\ insBound(int,\ int,\ int)
comment50.text=\n\ Method\ to\ process\ the\ bound\ instruction\n\ if\ (reg1<0\ ||\ reg1>\=[reg0+rela])\n\ \ \ throw\ exception\ index\ out\ of\ bounds\n\ @param\ reg0\ contains\ the\ address\ of\ the\ array\n\ @param\ reg1\ contains\ the\ desired\ index\n\ @param\ rela\ the\ offset\ of\ the\ length\ entry\ in\ the\ array\ object\n\ @return\ true\ if\ the\ operation\ succeeds,\ false\ otherwise\n
comment51.params=reg0\ reg1\ reg2\ rela\ para
comment51.target=boolean\ insDeref(int,\ int,\ int,\ int,\ int)
comment51.text=\n\ Method\ to\ process\ the\ deref\ instruction.\ Only\ the\ address\ of\ the\ desired\n\ element\ is\ calculated\n\ reg0\ <-\ reg1+rela+reg2*para\n\ @param\ reg0\ pointer\ to\ the\ array\ (must\ be\ pointer\ sized)\n\ @param\ reg1\ index\ register\ (index\ of\ the\ desired\ element)\n\ @param\ rela\ base\ offset\ \n\ @param\ para\ size\ of\ array\ entries\n\ @return\ true\ if\ the\ operation\ succeeds,\ false\ otherwise\n
comment52.params=reg0
comment52.target=boolean\ insMovemap(int)
comment52.text=\n\ Method\ to\ process\ the\ movemap\ instruction\n\ reg0.upperPtr\ <-\ SReg[5]\ (SReg[5]\ has\ to\ be\ pointer)\n\ @param\ reg0\ destination\ register\ must\ be\ double\ pointer\ sized\n\ @return\ true\ if\ the\ operation\ succeeds,\ false\ otherwise\n
comment53.params=reg0\ size\ restore
comment53.target=boolean\ insAllocReg(int,\ int,\ boolean)
comment53.text=\n\ Method\ to\ process\ the\ allocreg\ instruction.\ Allocate\ the\ register\n\ @param\ reg0\ register\ to\ allocate\n\ @param\ size\ the\ size\ of\ the\ register\n\ @return\ true\ if\ the\ operation\ succeeds,\ false\ otherwise\n
comment54.params=reg0
comment54.target=boolean\ insKillReg(int)
comment54.text=\n\ Method\ to\ process\ the\ kill\ reg\ instruction.\ Clean\ up\ register\n\ @param\ reg0\ the\ register\ to\ clean\n\ @return\ true\ if\ the\ operation\ succeeds,\ false\ otherwise\n
comment55.params=reg0
comment55.target=boolean\ insKillOJmp(int)
comment56.params=reg0\ reg1
comment56.target=boolean\ insRegrange(int,\ int)
comment56.text=\n\ Method\ to\ set\ the\ current\ start-offset\ in\ register\ array\ after\ call\n\ @param\ reg0\ first\ currently\ used\ register\ (the\ new\ start-offset)\ \n\ @param\ reg1\ last\ currently\ used\ register\n\ @return\ true\ if\ the\ operation\ succeeds,\ false\ otherwise\n
comment57.params=nr
comment57.target=boolean\ insException(int)
comment57.text=\n\ Method\ to\ simulate\ a\ native\ exception\n\ @param\ nr\ exception\ code\ \n\ @return\ false\ always\ (do\ not\ proceed\ in\ execution)\n
comment58.params=reg0\ tfo\ destRela
comment58.target=boolean\ insThrowFrameBuild(int,\ int,\ int)
comment58.text=\n\ Method\ to\ build\ the\ throw\ frame\n\ @param\ reg0\ register\ containing\ globalAddr\n\ @param\ tbo\ \ offset\ of\ throw-frame\ relative\ to\ stack\ frame\ pointer\n\ @param\ dest\ relative\ target\ address\n\ @return\ true\ if\ the\ operation\ succeeds,\ false\ otherwise\n
comment59.params=secondCall\ tfo\ destRela
comment59.target=boolean\ insThrowFrameUpdate(boolean,\ int,\ int)
comment59.text=\n\ Method\ to\ update\ the\ throw\ frame,\ called\ twice\ for\ each\ update\n\ @param\ tbo\ \ offset\ of\ throw-frame\ relative\ to\ stack\ frame\ pointer\n\ @param\ dest\ relative\ target\ address\n\ @return\ true\ if\ the\ operation\ succeeds,\ false\ otherwise\n
comment6.params=imI
comment6.target=boolean\ insMarker(int)
comment6.text=\n\ Method\ to\ process\ the\ marker\ instruction\n\ TODO\ fuer\ jede\ Methode\ enter\ -\ marker\ -\ nfreg\ -\ code\ -\ leave\n\ Wird\ vom\ Programmierer\ gesetzt.\ Gibt\ an,\ ob\ es\ sich\ bspw.\ um\ eine\n\ Interrupt-Methode\ handelt\ -\ bis\ jetzt\ ignorieren\ \n\ @param\ imI\n\ @return\ true\ if\ the\ operation\ succeeds,\ false\ otherwise\n
comment60.params=reg0\ tbo
comment60.target=boolean\ insThrowFrameReset(int,\ int)
comment60.text=\n\ Method\ to\ reset\ the\ throw\ frame\n\ @param\ reg0\ register\ containing\ globalAddr\n\ @param\ tbo\ \ offset\ of\ throw-frame\ relative\ to\ stack\ frame\ pointer\n\ @return\ true\ if\ the\ operation\ succeeds,\ false\ otherwise\n
comment61.params=reg0
comment61.target=boolean\ insStackExtremeCheck(int)
comment61.text=\n\ Method\ to\ check\ stack\ pointer,\ set\ cmpBound\ flag\ for\ following\ CC_BO\ conditional\ jump\n\ @param\ reg0\ register\ containing\ maximum\ valid\ stack\ value\n\ @return\ true\ if\ the\ operation\ succeeds,\ false\ otherwise\n
comment62.params=
comment62.target=boolean\ insDoThrow()
comment62.text=\n\ Method\ to\ emulate\ the\ doThrow\ method\ usually\ implemented\ in\ the\ runtime\ system\n\ @return\ true\ if\ the\ operation\ succeeds,\ false\ otherwise\n
comment63.params=
comment63.target=int\ readByte()
comment63.text=\n\ Method\ to\ read\ a\ byte\ from\ where\ the\ instruction\ pointer\ currently\ points\n\ at\ \n\ @return\ the\ byte\ at\ that\ position\n
comment64.params=
comment64.target=int\ readInt()
comment64.text=\n\ Method\ to\ read\ an\ int\ from\ where\ the\ instruction\ pointer\ currently\ points\n\ at\ \n\ @return\ the\ int\ lying\ at\ that\ position\n
comment65.params=
comment65.target=long\ readLong()
comment65.text=\n\ Method\ to\ read\ a\ long\ from\ where\ the\ instruction\ pointer\ currently\ points\n\ at\ \n\ @return\ the\ long\ lying\ at\ that\ position\n
comment66.params=into
comment66.target=boolean\ step(boolean)
comment66.text=\n\ Method\ performing\ a\ single\ step\ with\ the\ given\ program\n\ @param\ into\ true,\ if\ the\ emulator\ should\ step\ into\ methods,\ false\ to\ step\n\ over\n
comment67.params=startIP
comment67.target=sjc.emulation.MethodDisassembly\ getMnemonicList(int)
comment67.text=\n\ @see\ Emulator\#getMnemonicList(int)\n
comment68.params=
comment68.target=int\ getCurrentIP()
comment68.text=\n\ @see\ Emulator\#getCurrentIP()\n
comment69.params=currIP
comment69.target=int\ getStartOfMethod(int)
comment69.text=\n\ @see\ Emulator\#getStartOfMethod()\n
comment7.params=imI\ para\ inline
comment7.target=boolean\ insEnter(int,\ int,\ boolean)
comment7.text=\n\ Method\ to\ process\ the\ enter\ instruction\n\ @param\ imI\ variable\ size,\ needed\ place\ on\ the\ stack\ for\ local\ variables\n\ @param\ para\ parameter\ size,\ to\ be\ removed\ at\ leave\n\ @return\ true\ if\ the\ operation\ succeeds,\ false\ otherwise\n
comment70.params=currIP
comment70.target=int\ getEndOfMethod(int)
comment70.text=\n\ @see\ Emulator\#getEndOfMethod()\n
comment71.params=
comment71.target=int\ getCurrentSP()
comment71.text=\n\ @see\ Emulator\#getCurrentSP()\n
comment8.params=imI
comment8.target=boolean\ insNFReg(int)
comment8.text=\n\ Method\ to\ process\ the\ NFReg\ instruction.\n\ Contains\ number\ of\ next\ free\ register\n\ @param\ imI\ number\ of\ the\ next\ free\ register\n\ @return\ true\ if\ the\ operation\ succeeds,\ false\ otherwise\n\ TODO\ Sicherstellen,\ dass\ alle\ Register\ Platz\ finden\n
comment9.params=
comment9.target=void\ resetRegisters()
numComments=72
