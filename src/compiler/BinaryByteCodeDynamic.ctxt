#BlueJ class context
comment0.target=BinaryByteCodeDynamic
comment1.params=
comment1.target=BinaryByteCodeDynamic()
comment10.params=entry
comment10.target=void\ call(jx.compiler.symbols.SymbolTableEntryBase)
comment10.text=\n\ \ \ \ \ \ \ Insert\ call\ near\ (Symbol)\ (1\ clks)\n\ @param\ entry\n
comment100.params=
comment100.target=java.lang.String\ getBinaryCodeAsAssembler()
comment101.params=instr\ arg1\ arg2
comment101.target=void\ printInstr(java.lang.String,\ java.lang.String,\ jx.compiler.symbols.SymbolTableEntryBase)
comment102.params=instr\ arg1\ arg2
comment102.target=void\ printInstr(java.lang.String,\ jx.compiler.symbols.SymbolTableEntryBase,\ java.lang.String)
comment103.params=instr\ arg1\ arg2\ arg3
comment103.target=void\ printInstr(java.lang.String,\ java.lang.String,\ jx.compiler.symbols.SymbolTableEntryBase,\ java.lang.String)
comment104.params=instr
comment104.target=void\ printInstr(java.lang.String)
comment105.params=instr\ arg1\ arg2
comment105.target=void\ printInstr(java.lang.String,\ java.lang.String,\ java.lang.String)
comment106.params=instr\ arg1
comment106.target=void\ printInstr(java.lang.String,\ jx.compiler.symbols.SymbolTableEntryBase)
comment107.params=entry
comment107.target=void\ printJumpTarget(jx.compiler.symbols.UnresolvedJump)
comment108.params=value
comment108.target=void\ printHexByte(int)
comment109.params=value
comment109.target=void\ printHexInt(int)
comment11.params=
comment11.target=void\ ret()
comment11.text=\n\ \ \ \ \ \ \ Insert\ return\n
comment110.params=
comment110.target=void\ printInstructions()
comment111.params=out
comment111.target=void\ printGASInstructions(java.io.PrintStream)
comment112.params=bcPosition
comment112.target=void\ startBC(int)
comment113.params=
comment113.target=void\ endBC()
comment114.params=
comment114.target=java.util.ArrayList\ getInstructionTable()
comment12.params=reg
comment12.target=void\ push(jx.compiler.nativecode.Reg)
comment12.text=\n\ \ \ \ \ \ \ Insert\ a\ pushl(reg)\n\ @param\ reg\n
comment13.params=ref
comment13.target=void\ push(jx.compiler.nativecode.Ref)
comment14.params=immd
comment14.target=void\ push(int)
comment15.params=entry
comment15.target=void\ push(jx.compiler.symbols.SymbolTableEntryBase)
comment16.params=reg
comment16.target=void\ pop(jx.compiler.nativecode.Reg)
comment16.text=\ \n\ \ \ \ \ \ \ Insert\ a\ popl(reg)\n\ @param\ reg\n
comment17.params=
comment17.target=void\ pop2()
comment17.text=\n\ \ \ \ \ \ \ pop\ stack\ into\ eflags\ register\ (4\ clks)\n
comment18.params=src\ des
comment18.target=void\ isub(jx.compiler.nativecode.Opr,\ jx.compiler.nativecode.Reg)
comment18.text=\n\ \ \ \ \ \ \ Integer\ Subtraction\n\ @param\ src\n\ @param\ des\n
comment19.params=src\ des
comment19.target=void\ isub(jx.compiler.nativecode.Reg,\ jx.compiler.nativecode.Ref)
comment2.params=
comment2.target=int\ getCurrentIP()
comment2.text=\n\ \ \ \ public\ jx.jit.nativecode.BinaryCode\ getOldBinaryCode()\ {\n\n\ \ \ \ Enumeration\ enum\ \=\ symbolTable.elements();\ \n\ \ \ \ Vector\ unresolvedEntries\ \=\ new\ Vector();\ \n\ \ \ \ while(enum.hasMoreElements())\ {\n\ \ \ \ \ \ \ \ SymbolTableEntryBase\ entry\ \=\ (SymbolTableEntryBase)enum.nextElement();\n\ \ \ \ \ \ \ \ if\ (entry\ instanceof\ IntValueSTEntry)\ {\n\ \ \ \ \ \ \ \ ((IntValueSTEntry)entry).applyValue(code);\n\ \ \ \ \ \ \ \ //entry.apply(code,\ codeBase);\n\ \ \ \ \ \ \ \ }\ else\ {\n\ \ \ \ \ \ \ \ unresolvedEntries.addElement(entry);\ \n\ \ \ \ \ \ \ \ }\n\ \ \ \ }\n\ \ \ \ symbolTable\ \=\ unresolvedEntries;\ \n\n\ \ \ \ \ \ return\ new\ jx.jit.nativecode.BinaryCode(code,\ ip,\ symbolTable);\ \n\ \ \ \ }\n
comment20.params=immd\ des
comment20.target=void\ isub(int,\ jx.compiler.nativecode.Opr)
comment21.params=entry\ des
comment21.target=void\ isub(jx.compiler.symbols.SymbolTableEntryBase,\ jx.compiler.nativecode.Opr)
comment22.params=src
comment22.target=void\ imul(jx.compiler.nativecode.Opr)
comment22.text=\n\ \ \ \ \ \ \ Integer\ Unsigned\ Multiplication\ of\ eax\ \ (10\ clk)\n\ @param\ src\n
comment23.params=opr\ reg
comment23.target=void\ lea(jx.compiler.nativecode.Opr,\ jx.compiler.nativecode.Reg)
comment23.text=\ \n\ \ \ \ lea\ Load\ Effective\ Address\ (1\ clk)\n\ \ \n\ \ \ \ \ \ \ \ m\ \=\ index\ *\ [0,1,2,4,8]\ +\ base\ +\ disp\n\n\ \ \ \ \ \ \ \ base.disp(disp,index,[0,1,2,4,8])\n\ @param\ opr\ \ \ \ \ \ \ \ \n\ @param\ reg\ \ \ \ \ \ \ \ \n
comment24.params=immd\ des
comment24.target=void\ ishl(int,\ jx.compiler.nativecode.Opr)
comment24.text=\n\ \ \ \ \ \ \ SHL/SAL\ Shift\ left\ (1/3\ clks)\n\ @param\ immd\n\ @param\ des\n
comment25.params=des
comment25.target=void\ ishl(jx.compiler.nativecode.Opr)
comment25.text=\n\ \ \ \ \ \ \ SHL/SAL\ Shift\ left\ by\ %cl\ (4\ clks)\n\ @param\ des\n
comment26.params=immd\ des
comment26.target=void\ ishr(int,\ jx.compiler.nativecode.Opr)
comment26.text=\n\ \ \ \ \ \ \ SHR\ Shift\ right\ (1/3\ clks)\n\ @param\ immd\n\ @param\ des\n
comment27.params=entry\ des
comment27.target=void\ ishr(jx.compiler.symbols.SymbolTableEntryBase,\ jx.compiler.nativecode.Opr)
comment28.params=src
comment28.target=void\ idiv(jx.compiler.nativecode.Opr)
comment28.text=\n\ \ \ \ \ \ \ DIV\ Signed\ Divide\n\ @param\ src\n
comment29.params=src\ des
comment29.target=void\ iadd(jx.compiler.nativecode.Opr,\ jx.compiler.nativecode.Reg)
comment29.text=\n\ \ \ \ \ \ \ Add\n\ @param\ src\n\ @param\ des\n
comment3.params=
comment3.target=void\ realloc()
comment30.params=src\ des
comment30.target=void\ iadd(jx.compiler.nativecode.Reg,\ jx.compiler.nativecode.Ref)
comment31.params=immd\ des
comment31.target=void\ iadd(int,\ jx.compiler.nativecode.Opr)
comment32.params=entry\ des
comment32.target=void\ iadd(jx.compiler.symbols.SymbolTableEntryBase,\ jx.compiler.nativecode.Opr)
comment33.params=src\ des
comment33.target=void\ iand(jx.compiler.nativecode.Opr,\ jx.compiler.nativecode.Reg)
comment33.text=\n\ \ \ \ \ \ \ And\ (1/3\ clks)\n
comment34.params=src\ des
comment34.target=void\ iand(jx.compiler.nativecode.Reg,\ jx.compiler.nativecode.Ref)
comment35.params=immd\ des
comment35.target=void\ iand(int,\ jx.compiler.nativecode.Opr)
comment36.params=entry\ des
comment36.target=void\ iand(jx.compiler.symbols.SymbolTableEntryBase,\ jx.compiler.nativecode.Opr)
comment37.params=src\ des
comment37.target=void\ ior(jx.compiler.nativecode.Opr,\ jx.compiler.nativecode.Reg)
comment37.text=\n\ \ \ \ \ \ \ Or\ (1/3\ clks)\n
comment38.params=src\ des
comment38.target=void\ ior(jx.compiler.nativecode.Reg,\ jx.compiler.nativecode.Ref)
comment39.params=immd\ des
comment39.target=void\ ior(int,\ jx.compiler.nativecode.Opr)
comment4.params=requiredSpace
comment4.target=void\ realloc(int)
comment4.text=\ \n\ Realloc\ memory\ in\ the\ byte\ code\ array.\ \n\ After\ calling\ this\ method,\ there\ are\ at\ least\ \n\ \ \ \ '*\ requiredSpace'\ free\ bytes\ in\ the\ array.\ \n\ @param\ requiredSpace\n
comment40.params=entry\ des
comment40.target=void\ ior(jx.compiler.symbols.SymbolTableEntryBase,\ jx.compiler.nativecode.Opr)
comment41.params=src\ des
comment41.target=void\ ixor(jx.compiler.nativecode.Opr,\ jx.compiler.nativecode.Reg)
comment41.text=\n\ \ \ \ \ \ \ Or\ (1/3\ clks)\n
comment42.params=src\ des
comment42.target=void\ ixor(jx.compiler.nativecode.Reg,\ jx.compiler.nativecode.Ref)
comment43.params=immd\ des
comment43.target=void\ ixor(int,\ jx.compiler.nativecode.Opr)
comment44.params=entry\ des
comment44.target=void\ ixor(jx.compiler.symbols.SymbolTableEntryBase,\ jx.compiler.nativecode.Opr)
comment45.params=opr
comment45.target=void\ notl(jx.compiler.nativecode.Opr)
comment45.text=\n\ \ \ \ \ \ \ Not\ (1/3\ clks)\n
comment46.params=opr
comment46.target=void\ ineg(jx.compiler.nativecode.Opr)
comment46.text=\n\ \ \ \ \ \ \ Neg\ (1/3\ clks)\n
comment47.params=src\ des
comment47.target=void\ adc(jx.compiler.nativecode.Opr,\ jx.compiler.nativecode.Reg)
comment47.text=\n\ \ \ \ \ \ \ Add\ with\ Carry\n
comment48.params=src\ des
comment48.target=void\ adc(jx.compiler.nativecode.Reg,\ jx.compiler.nativecode.Ref)
comment49.params=src\ des
comment49.target=void\ cmp(jx.compiler.nativecode.Opr,\ jx.compiler.nativecode.Reg)
comment49.text=\n\ \ \ \ \ \ \ Compare\ Two\ Operands\n
comment5.params=value
comment5.target=void\ insertByte(int)
comment5.text=\ \n\ \ \ \ Insert\ a\ single\ byte\n
comment50.params=src\ des
comment50.target=void\ cmp(jx.compiler.nativecode.Reg,\ jx.compiler.nativecode.Ref)
comment51.params=immd\ des
comment51.target=void\ lcmp(int,\ jx.compiler.nativecode.Opr)
comment52.params=entry\ des
comment52.target=void\ lcmp(jx.compiler.symbols.SymbolTableEntryBase,\ jx.compiler.nativecode.Opr)
comment53.params=nr
comment53.target=void\ intr(int)
comment54.params=rel
comment54.target=void\ ifeq(int)
comment54.text=\n\ \ \ \ \ \ \ Jump\ short/near\ if\ equal\n
comment55.params=entry
comment55.target=void\ ifeq(jx.compiler.symbols.SymbolTableEntryBase)
comment56.params=rel
comment56.target=void\ ifne(int)
comment56.text=\n\ \ \ \ \ \ \ Jump\ short/near\ if\ not\ equal\n
comment57.params=entry
comment57.target=void\ ifne(jx.compiler.symbols.SymbolTableEntryBase)
comment58.params=entry
comment58.target=void\ jnae(jx.compiler.symbols.SymbolTableEntryBase)
comment59.params=entry
comment59.target=void\ iflt(jx.compiler.symbols.SymbolTableEntryBase)
comment59.text=\n\ \ \ \ \ \ \ Jump\ short/near\ if\ less\n
comment6.params=entry
comment6.target=void\ insertByte(jx.compiler.symbols.SymbolTableEntryBase)
comment60.params=entry
comment60.target=void\ ifge(jx.compiler.symbols.SymbolTableEntryBase)
comment60.text=\n\ \ \ \ \ \ \ Jump\ short/near\ if\ greater\ or\ equal\n
comment61.params=entry
comment61.target=void\ ifgt(jx.compiler.symbols.SymbolTableEntryBase)
comment61.text=\n\ \ \ \ \ \ \ Jump\ short/near\ if\ greater\n
comment62.params=entry
comment62.target=void\ ifle(jx.compiler.symbols.SymbolTableEntryBase)
comment62.text=\n\ \ \ \ \ \ \ Jump\ short/near\ if\ less\ or\ equal\n
comment63.params=rel
comment63.target=void\ js(int)
comment63.text=\n\ \ \ \ \ \ \ Jump\ short/near\ if\ sign\n
comment64.params=rel
comment64.target=void\ goto_(int)
comment64.text=\n\ \ \ \ \ \ \ Jump\ short/near\ \n
comment65.params=des
comment65.target=void\ goto_(jx.compiler.nativecode.Opr)
comment66.params=entry
comment66.target=void\ goto_(jx.compiler.symbols.SymbolTableEntryBase)
comment67.params=index\ tables
comment67.target=void\ goto_(jx.compiler.nativecode.Reg,\ jx.compiler.symbols.SymbolTableEntryBase[])
comment68.params=src\ des
comment68.target=void\ mov(jx.compiler.nativecode.Opr,\ jx.compiler.nativecode.Reg)
comment68.text=\n\ \ \ \ \ \ \ Move\ 32\ Bit\ Data\n
comment69.params=src\ des
comment69.target=void\ mov(jx.compiler.nativecode.Reg,\ jx.compiler.nativecode.Ref)
comment7.params=reg\ rm
comment7.target=void\ insertModRM(int,\ jx.compiler.nativecode.Opr)
comment7.text=\n\ \ \ \ \ \ \ Insert\ ModRM\ and\ SIB\ byte\ \n
comment70.params=immd\ des
comment70.target=void\ mov(int,\ jx.compiler.nativecode.Opr)
comment71.params=entry\ des
comment71.target=void\ mov(jx.compiler.symbols.SymbolTableEntryBase,\ jx.compiler.nativecode.Opr)
comment72.params=
comment72.target=void\ nop()
comment72.text=\n\ \ \ \ \ \ \ No\ Operation\ (1\ clks)\n
comment73.params=src\ des
comment73.target=void\ if_icmpeq(jx.compiler.nativecode.Opr,\ jx.compiler.nativecode.Reg)
comment73.text=\n\ \ \ \ \ \ \ test\ -\ logical\ compare\ (1/2\ clks)\n
comment74.params=immd\ des
comment74.target=void\ if_icmpeq(int,\ jx.compiler.nativecode.Opr)
comment75.params=value
comment75.target=void\ insertConst1(int)
comment75.text=\ \n\ \ \ \ Insert\ a\ single\ byte\ constant\ \n
comment76.params=value
comment76.target=void\ insertConst4(int)
comment76.text=\ \n\ \ \ \ Insert\ a\ four\ byte\ constant\ \n
comment77.params=ncIndex\ value
comment77.target=void\ insertConst4At(int,\ int)
comment78.params=entry
comment78.target=void\ insertConst4(jx.compiler.symbols.SymbolTableEntryBase)
comment78.text=\ \n\ \ \ \ Insert\ a\ four\ byte\ constant\ with\ an\ unknown\ value.\ \n\ \ \ \ (must\ be\ resolved\ before\ the\ code\ is\ installed)\ \n
comment79.params=value
comment79.target=boolean\ is8BitValue(int)
comment8.params=reg\ rm
comment8.target=void\ insertModRM(jx.compiler.nativecode.Reg,\ jx.compiler.nativecode.Opr)
comment80.params=entry
comment80.target=void\ insertConst0(jx.compiler.symbols.SymbolTableEntryBase)
comment80.text=\ \n\ \ \ \ Insert\ a\ 0\ byte\ constant\ with\ an\ unknown\ value.\ \n\ \ \ \ (contains\ information\ about\ current\ code\ position,\ i.e.,\ a\ stack\ map)\ \n
comment81.params=
comment81.target=void\ alignCode()
comment81.text=\n\ \ \ \ \ \ \ Intel\ Architecture\ Optimization.\ Reference\ Manual\ (chapter\ 2,page\ 11)\n\ \ \ \ \ \ \ "Pentium\ II\ and\ III\ processors\ have\ a\ cache\ line\ size\ of\ 32\ byte.\n\ \ \ \ \ \ \ Since\ the\ instruction\ prefetch\ buffers\ fetch\ 16-byte\ boundaries,\n\ \ \ \ \ \ \ code\ alignment\ has\ a\ direct\ impact\ on\ prefetch\ buffer\ efficiency"\n\ \ \ \ \ \ \ \n\ Loop\ entry\ labels\ should\ be\ 16-byte-aligned\ when\ less\ then\ \n\ \ \ \ \ \ \ eight\ byte\ away\ from\ a\ 16-byte\ boundary.\n\ \ \ \ \ \ \ \n\ Labels\ that\ follow\ an\ unconditional\ branch\ of\ function\ call\n\ \ \ \ \ \ \ should\ be\ aligend\ as\ above.\n\ \ \ \ \ \ \ \n\ Labels\ that\ follow\ a\ conditional\ branch\ need\ _not_\ be\ aligned.\n
comment82.params=jumpObject
comment82.target=void\ addJumpTarget(jx.compiler.symbols.UnresolvedJump)
comment82.text=\ \n\ \ \ \ Initialized\ the\ target\ position\ of\ 'jumpObject'.\ \n\ \ \ \ (Call\ insertConst4()\ for\ corresponding\ jump\ instruction)\ \n
comment83.params=
comment83.target=void\ alignIP()
comment84.params=
comment84.target=void\ alignIP_4_Byte()
comment85.params=
comment85.target=void\ alignIP_16_Byte()
comment86.params=
comment86.target=void\ alignIP_32_Byte()
comment87.params=handler
comment87.target=void\ addExceptionTarget(jx.compiler.symbols.UnresolvedJump)
comment88.params=entry
comment88.target=void\ makeRelative(jx.compiler.symbols.SymbolTableEntryBase)
comment88.text=\ \n\ \ \ \ Make\ a\ symbol\ table\ entry\ relative.\ \n\ \ \ \ If\ you\ use\ insertConst4(),\ this\ class\ assumes\ that\ \n\ \ \ \ the\ value\ to\ be\ inserted\ is\ absolute.\ But\ if\ the\ \n\ \ \ \ inserted\ value\ is\ a\ jump\ offset\ it\ is\ relative\ to\ \n\ \ \ \ the\ instruction\ pointer\ of\ the\ next\ instruction.\ \n\ \ \ \ That\ is\ what\ you\ can\ tell\ the\ compiler\ with\ this\ \n\ \ \ \ method.\ \n
comment89.params=
comment89.target=void\ endInstr()
comment89.text=\n\ \ \ \ \ \ \ Called\ after\ each\ instruction.\ \n
comment9.params=opr
comment9.target=void\ call(jx.compiler.nativecode.Opr)
comment9.text=\n\ \ \ \ \ \ \ Insert\ call\ near\ indirect\ (reg/mem)\ (2\ clks)\n\ @param\ opr\n
comment90.params=
comment90.target=void\ finishCode()
comment91.params=codeBase
comment91.target=void\ resolve(int)
comment91.text=\ \n\ \ \ \ Apply\ all\ resolveable\ symbol\ table\ entries.\n\ \ \ \ (e.g.\ insert\ jump\ offsets\ ....)\n\ \ \ \ After\ calling\ this\ method,\ the\ vector\ 'symbolTable'\ \n\ \ \ \ contains\ all\ symbol\ table\ entries\ that\ are\ not\ resolveable.\n\ \ \ \ If\ you\ want\ to\ install\ the\ compiled\ code\ after\ calling\ this\ \n\ \ \ \ method,\ this\ vector\ should\ be\ empty.\ \n\ @param\ codeBase\n
comment92.params=reg
comment92.target=java.lang.String\ regToString(int)
comment93.params=handler
comment93.target=void\ addExceptionRangeStart(jx.compiler.nativecode.NCExceptionHandler)
comment94.params=handler
comment94.target=void\ addExceptionRangeEnd(jx.compiler.nativecode.NCExceptionHandler)
comment95.params=handler
comment95.target=void\ addExceptionHandler(jx.compiler.nativecode.NCExceptionHandler)
comment95.text=\n\ add\ a\ start\ of\ an\ exception\ handler.\n\ @param\ handler\n
comment96.params=
comment96.target=jx.compiler.nativecode.NCExceptionHandler[]\ getExceptionHandlers()
comment96.text=\n\ \ \ \ return\ an\ array\ of\ all\ exception\ handlers\ of\ this\ \n\ \ \ \ method.\ (these\ handlers\ contain\ the\ native\ code\ indices\ \n\ \ \ \ of\ the\ range\ start,\ range\ end\ and\ of\ the\ handler\ start\ \n\ @return\n
comment97.params=firstByte\ stopByte
comment97.target=java.lang.String\ getBinaryCodeAsHex(int,\ int)
comment98.params=
comment98.target=java.lang.String\ getBinaryCodeAsHex()
comment99.params=firstByte\ stopByte
comment99.target=java.lang.String\ getBinaryCodeAsAssembler(int,\ int)
numComments=115
